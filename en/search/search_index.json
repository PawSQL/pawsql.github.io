{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"readme/","text":"PawSQL optimizes SQL queries by Clicks PawSQL Advisor \u00b6 In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Rules-based SQL auditing , targeting correctness auditing and performance optimization. Rewrite optimization , recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation , based on input SQL syntax, database objects and statistics information. What-if validation to ensure gaining better performance after SQL rewriting and indexing recommendations. Get started \u00b6 Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization recommendations will be presented to you. Paw Index Advisor \u00b6 Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if validation , make sure indexes recommended be used in later query execution Get started \u00b6 Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter [ Paw Index Advisor ] in martketplace and click install Configure the running parameters of Paw Index Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for minutes and recommended indexes will be presented to you to accelerate your database queries. Claim: PawSQL Advisor and Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Readme"},{"location":"readme/#pawsql-advisor","text":"In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"PawSQL Advisor"},{"location":"readme/#features","text":"Rules-based SQL auditing , targeting correctness auditing and performance optimization. Rewrite optimization , recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation , based on input SQL syntax, database objects and statistics information. What-if validation to ensure gaining better performance after SQL rewriting and indexing recommendations.","title":"Features"},{"location":"readme/#get-started","text":"Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization recommendations will be presented to you.","title":"Get started"},{"location":"readme/#paw-index-advisor","text":"Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"Paw Index Advisor"},{"location":"readme/#features_1","text":"Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if validation , make sure indexes recommended be used in later query execution","title":"Features"},{"location":"readme/#get-started_1","text":"Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter [ Paw Index Advisor ] in martketplace and click install Configure the running parameters of Paw Index Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for minutes and recommended indexes will be presented to you to accelerate your database queries. Claim: PawSQL Advisor and Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started"},{"location":"blog/","text":".md-sidebar--secondary:not([hidden]) { visibility: hidden; } Blog \u00b6 Four Pitfalls of SQL Processing with NULL Values \u00b6 NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic. In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7 In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you can will be able to cope with all the scenarios regarding to NULL value handling in your daily work. Continue reading Top 5 SQL Optimization Tools \u00b6 The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 10 5 read \u00b7 In this article, we evaluate five widely used SQL optimization tools, providing their cons and pros. Continue reading","title":"Blog"},{"location":"blog/#blog","text":"","title":"Blog"},{"location":"blog/#four-pitfalls-of-sql-processing-with-null-values","text":"NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic. In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7 In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you can will be able to cope with all the scenarios regarding to NULL value handling in your daily work. Continue reading","title":"Four Pitfalls of SQL Processing with NULL Values"},{"location":"blog/#top-5-sql-optimization-tools","text":"The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 10 5 read \u00b7 In this article, we evaluate five widely used SQL optimization tools, providing their cons and pros. Continue reading","title":"Top 5 SQL Optimization Tools"},{"location":"blog/2022/four_pitfalls_null_processing/","text":"Four Pitfalls of SQL Processing with NULL Values \u00b6 NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic . In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7 Overview \u00b6 In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you will be able to cope with all the scenarios regarding to NULL value handling in your daily work. Code of Examination \u00b6 The following examination logic covers all scenarios for NULL values in SQL processing, and by understanding the following logic, you can avoid the NULL pitfalls. The result of all comparison and arithmetic operators ( >, =, <, <>, <=, >=, +,-,*, / ) with NULL result is unknown The logical operations( AND, OR, NOT ) of unknown follows the truth values table of three-valued operations If the result of the operation is returned directly to the user, use NULL to represent unknown If the result of the operation is true or false as a condition during SQL processing, then the operation needs to be performed by the three-value logic, and the final result is determined by the following logic 4.1. {false\u3001unknown} -> false 4.2. {true} ->true In set operations such as UNION or INTERSECT , NULL values are considered equal to each other. Three-valued Logic 1 \u00b6 In logic, a three-valued logic (also trinary logic, trivalent, ternary, or trilean, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value. This is contrasted with the more commonly known bivalent logics (such as classical sentential or Boolean logic) which provide only for true and false. pitfalls of NULL Values \u00b6 Comparison with NULL Values \u00b6 Conclusion : expr = null can\u2019t determine the expression expr to be null , and is null should be used to determine whether the expr is null. Suppose there is a customer table with following five columns, among which two columns ( c_nationcode , c_phone ) are nullable. CREATE TABLE customer ( c_custkey int4 NOT NULL , c_name varchar ( 25 ) NOT NULL , c_nationcode char ( 8 ) NULL , c_phone varchar ( 15 ) NULL , c_regdate date NULL , CONSTRAINT customer_pkey PRIMARY KEY ( c_custkey ) ); insert into customer values ( 1 , 'Randy' , 'en' , '13910010010' , '20210911' ); insert into customer values ( 2 , 'Mandy' , null , '13910010012' , '20200211' ); insert into customer values ( 3 , 'Ray' , 'us' , null , '20180902' ); If a developer wants to find out the customers with empty phones through the following statement, he won't succeed because the result of following statement is always empty. select * from customer where c_phone = null ; The correct way should be\uff1a select * from customer where c_phone is null ; Let's examine according to the Code of Examination , the predicate c_phone = null is evaluated to unknown ; then according to Rule 4.1, unknown is treated as false . c_phone = null -> unknown -> false ; 2. Case When expression with NULL \u00b6 Conclusion : case expr when null can't determine if the expression is null, the correct way is case when expr is null . Problems in the where or having clause are easier to detect and correct, while it is much more difficult to dectect null usages in case when expressions, either by human or by existing SQL auditing tools. For example, if we want to decode the nation code to nation name, and the code is null, we want to set nation name to China : select c_name , case c_nationcode when 'us' then 'USA' when 'cn' then 'China' when null then 'China' else 'Others' end from customer The above statement does not convert the country code to null to China . Because when null is actually an operation performed by an c_nationcode = null . The correct way to to do it should be: select c_name , case when c_nationcode = 'us' then 'USA' when c_nationcode = 'cn' then 'China' when c_nationcode is null then 'China' else 'Others' end from customer 3. NOT IN with NULL \u00b6 Conclusion A predicate of a not in subquery with nullable select elements will always be evaluated to false. Suppose we have an orders table where the customer id( o_custkey ) and order date( o_orderdate ) are nullable due to missing data. CREATE TABLE orders ( o_orderkey int4 NOT NULL , o_custkey int4 NULL , o_orderdate date NULL , CONSTRAINT orders_pkey PRIMARY KEY ( o_orderkey ) ); insert into orders values ( 1 , 1 , '2021-01-01' ); insert into orders values ( 2 , null , '2020-09-01' ); insert into orders values ( 3 , 3 , null ); Now we want to find customers without orders for marketing. The expected result is the customer whose c_custkey is 2 , and the query statement might look like this, select * from customer where c_custkey not in ( select o_custkey from orders ) In fact, the above query return nothing to us. The reason is that the o_custkey in the subquery has null values, and the processing logic of NOT IN is like this c_custkey not in ( 1 \uff0c 3 , null ) \u2192 c_custkey <> 1 and c_custkey <> 3 and c_custkey <> null \u2192 c_custkey <> 1 and c_custkey <> 3 and unknown \u2192 unknown -> false In fact, if there are null values in the result set of the subquery, the SQL will always return empty result set. There are two correct ways: Add a NOT NULL predicate to the subquery, that is select * from customer where c_custkey not in ( select o_custkey from orders where o_custkey is not null ) Rewrite the NOT IN subquery to the not exists subquery, that is select * from customer where not exists ( select o_custkey from orders where o_custkey = c_custkey ) Note : PawSQL Advisor adopts the first method to do rewrite optimization, but it is more powerful, PawSQL Advisor first determines whether the columns in the subquery may be empty, and if it is possible, it will recommend the rewritten SQL to the user. 4. ALL Subquery with NULL \u00b6 Conclusion : A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. Suppose we want to find out the orders which are wrongly registered after the user is revoked. One of solution is this following query statement. select * from customer where c_regdate > ALL ( select o_orderdate from orders where c_custkey = o_custkey ) Similar to NOT IN above, this sql does not return the expected result due to the presence of NULL in the result of the subquery. The ALL operation is actually performed by comparing it with the returned result set, and then performing the AND operation, and the final result is unknown . While unknown as a condition to be evaluated is, the result is false . There are two ways to correct it: Add a NOT NULL predicate to the subquery, select * from customer where c_regdate > all ( select o_orderdate from orders where o_orderdate is not null ) Rewrite expr > all to aggregate scalar subquery expr > (select max()...) 2 select * from customer where c_regdate > ( select max ( o_custkey ) from orders ) Note : PawSQL Advisor adopts the second way to rewrite optimization, because PawSQL Advisor can further optimize the performance of the second rewritten SQL by rewriting ('max/min subquery rewrite rule'). NULL Optimization in PawSQL Advisor \u00b6 PawSQL Advisor has three rewrite optimization rules for NULL processing, corresponding to the four cases above. RuleCode Rule Description UseEqual4NullRewrite expr = null or case expr when null can't determine whether the expr is null , is null should be used NotInNullableSubQueryRewrite A predicate of a not in subquery with nullable select elements will always be evaluated to false. AllQualifierSubQueryRewrite A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. PawSQL Advisor is more powerful, it will be based on whether the definition of a column in the DDL is nullable, and whether the operation on the column will produce nullable results, to determine whether the query column in the subquery is nullable, if it is possible to be empty, it will recommend the rewritten SQL to the user. Logic of NotInNullableSubQueryRewrite iterate parse tree of input query \uff0c retrieve all the NOT IN predicate for each NOT IN predicate { if the predicate is PredicateInValueSelect ( ` expr not in ( select ....) ` ){ check whether result set of subquery is nullable if no \uff0c return ; if yes \uff0c for each nullabe SELECT element ( rc ){ check whether there is a predicate ` rc is not null ` in the subquery if no \uff0c create a predicate ` rc is not null ` and combine with the conditions of WHERE clause in the sub query ; if yes \uff0c continue ; } } if the predicate is PredicateInValueList ( ` expr not in values ( 1 , 2 , null ) ` ) for each value in the value list if the value is NULL \uff0c delete it } Logic of checking whether result set of subquery is nullable isNullable ( SELECT expr ){ if ( expr is column of a table ) { if ( column is defined nullable ) return true ; else return true ; } else if ( expr is NULL ) { return true ; } else if ( expr is constant of variable ) { return false ; } else if ( expr is a combined expr ){ return ( arg1 || arg2 || ...); } else if ( expr is a function ) { if ( the function is one of ( \"SUM\" , \"Count\" , \"AVG\" )) return false ; else return isNullable ( arguements of the function ) } else if ( expr is SSQ ) { return isNullable ( SELECT expr of the SSQ ) } else { return true ; } } Examination of The PawSQL Advisor regarding to NULL processing \u00b6 Sever cases of NULL handling are demonstrated. The columns c_phone and c_nationkey in the customer table definition are nullable. -- Case 1: = null rewritten to is null select count ( * ) from customer where c_phone = null ; -- Case 2: case expr when null is rewritten to case when expr is null select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer where not c_phone = null ; -- Case 3: c_nationkey nullable, increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Case 4: c_nationkey nullable, so max(c_nationkey) is nullable, increasing the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Case 5: count()/sum() is never empty, so there is no need to rewrite it select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Case 6: c_name is not null, but c_nationkey nullable, so you need to increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); -- Case 7: c_nationkey is nullable, so it is rewritten as > (select min(c_nationkey) from customer) select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer ); PawSQL Advisor Output (Summary) \u00b6 /********************************************************************\\ * * * PawSQL Optimization Summary * * * * Powered by PawSQL(2021- ) * * * \\********************************************************************/ 1 . Optimization Summary - There are 7 query analyzed ; - There are 6 optimization rewrites for 6 queries ; - There are 9 violations of optimization rule against 6 queries ; - There are 1 indices recommended for 4 queries ; - There is 12 . 91 % performance improvement . 2 . Optimization Rule Violations - RuleUseEqual4Null : [ null . sql - stmt2 , null . sql - stmt1 ] - RuleAllQualifierSubQueryRewrite : [ null . sql - stmt7 ] - RuleNoCond4NonAggSelect : [ null . sql - stmt3 , null . sql - stmt6 , null . sql - stmt7 ] - RuleNotInNullableSubQueryRewrite : [ null . sql - stmt4 , null . sql - stmt3 , null . sql - stmt6 ] ... PawSQL Advisor Output (single SQL details) \u00b6 Case 1: = null rewritten to is null -- Original SQL select count ( * ) from customer where c_phone = null ; -- Rewritten SQL select count ( * ) from customer where customer . c_phone is null ; Case 2: case expr when null rewritten as case when expr is null -- Original SQL select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer ; -- Rewritten SQL select case when c_phone is null then 1 when c_phone = '139%' then 0 else - 1 end from customer ; Case 3: c_nationkey is nullable, add the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer where c_nationkey is not null ) Case 4: c_nationkey is nullable, so max(c_nationkey) is nullable, adding the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select max ( customer . c_nationkey ) from customer where c_nationkey is not null group by c_mktsegment ) Case 5: count(c_nationkey) is never empty, so there is no need to rewrite it. select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); Case 6: c_name is not empty, but c_nationkey is nullable, so the c_nationkey is not null condition needs to be added. -- Original SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer where customer . c_nationkey is not null ) Case 7: c_nationkey is nullable, so rewritten as > (select min(c_nationkey) from customer) -- Original SQL select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from customer where n_nationkey > ( select min ( c_nationkey ) from customer ) https://en.wikipedia.org/wiki/Three-valued_logic \u21a9 If expr < all or expr < = all , then rewrite it as expr < (select min() ...) \u21a9","title":"Four pitfalls of SQL Processing with NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#four-pitfalls-of-sql-processing-with-null-values","text":"NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic . In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7","title":"Four Pitfalls of SQL Processing with NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#overview","text":"In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you will be able to cope with all the scenarios regarding to NULL value handling in your daily work.","title":"Overview"},{"location":"blog/2022/four_pitfalls_null_processing/#code-of-examination","text":"The following examination logic covers all scenarios for NULL values in SQL processing, and by understanding the following logic, you can avoid the NULL pitfalls. The result of all comparison and arithmetic operators ( >, =, <, <>, <=, >=, +,-,*, / ) with NULL result is unknown The logical operations( AND, OR, NOT ) of unknown follows the truth values table of three-valued operations If the result of the operation is returned directly to the user, use NULL to represent unknown If the result of the operation is true or false as a condition during SQL processing, then the operation needs to be performed by the three-value logic, and the final result is determined by the following logic 4.1. {false\u3001unknown} -> false 4.2. {true} ->true In set operations such as UNION or INTERSECT , NULL values are considered equal to each other.","title":"Code of Examination"},{"location":"blog/2022/four_pitfalls_null_processing/#three-valued-logic1","text":"In logic, a three-valued logic (also trinary logic, trivalent, ternary, or trilean, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value. This is contrasted with the more commonly known bivalent logics (such as classical sentential or Boolean logic) which provide only for true and false.","title":"Three-valued Logic1"},{"location":"blog/2022/four_pitfalls_null_processing/#pitfalls-of-null-values","text":"","title":"pitfalls of NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#comparison-with-null-values","text":"Conclusion : expr = null can\u2019t determine the expression expr to be null , and is null should be used to determine whether the expr is null. Suppose there is a customer table with following five columns, among which two columns ( c_nationcode , c_phone ) are nullable. CREATE TABLE customer ( c_custkey int4 NOT NULL , c_name varchar ( 25 ) NOT NULL , c_nationcode char ( 8 ) NULL , c_phone varchar ( 15 ) NULL , c_regdate date NULL , CONSTRAINT customer_pkey PRIMARY KEY ( c_custkey ) ); insert into customer values ( 1 , 'Randy' , 'en' , '13910010010' , '20210911' ); insert into customer values ( 2 , 'Mandy' , null , '13910010012' , '20200211' ); insert into customer values ( 3 , 'Ray' , 'us' , null , '20180902' ); If a developer wants to find out the customers with empty phones through the following statement, he won't succeed because the result of following statement is always empty. select * from customer where c_phone = null ; The correct way should be\uff1a select * from customer where c_phone is null ; Let's examine according to the Code of Examination , the predicate c_phone = null is evaluated to unknown ; then according to Rule 4.1, unknown is treated as false . c_phone = null -> unknown -> false ;","title":"Comparison with NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#2-case-when-expression-with-null","text":"Conclusion : case expr when null can't determine if the expression is null, the correct way is case when expr is null . Problems in the where or having clause are easier to detect and correct, while it is much more difficult to dectect null usages in case when expressions, either by human or by existing SQL auditing tools. For example, if we want to decode the nation code to nation name, and the code is null, we want to set nation name to China : select c_name , case c_nationcode when 'us' then 'USA' when 'cn' then 'China' when null then 'China' else 'Others' end from customer The above statement does not convert the country code to null to China . Because when null is actually an operation performed by an c_nationcode = null . The correct way to to do it should be: select c_name , case when c_nationcode = 'us' then 'USA' when c_nationcode = 'cn' then 'China' when c_nationcode is null then 'China' else 'Others' end from customer","title":"2. Case When expression with NULL"},{"location":"blog/2022/four_pitfalls_null_processing/#3-not-in-with-null","text":"Conclusion A predicate of a not in subquery with nullable select elements will always be evaluated to false. Suppose we have an orders table where the customer id( o_custkey ) and order date( o_orderdate ) are nullable due to missing data. CREATE TABLE orders ( o_orderkey int4 NOT NULL , o_custkey int4 NULL , o_orderdate date NULL , CONSTRAINT orders_pkey PRIMARY KEY ( o_orderkey ) ); insert into orders values ( 1 , 1 , '2021-01-01' ); insert into orders values ( 2 , null , '2020-09-01' ); insert into orders values ( 3 , 3 , null ); Now we want to find customers without orders for marketing. The expected result is the customer whose c_custkey is 2 , and the query statement might look like this, select * from customer where c_custkey not in ( select o_custkey from orders ) In fact, the above query return nothing to us. The reason is that the o_custkey in the subquery has null values, and the processing logic of NOT IN is like this c_custkey not in ( 1 \uff0c 3 , null ) \u2192 c_custkey <> 1 and c_custkey <> 3 and c_custkey <> null \u2192 c_custkey <> 1 and c_custkey <> 3 and unknown \u2192 unknown -> false In fact, if there are null values in the result set of the subquery, the SQL will always return empty result set. There are two correct ways: Add a NOT NULL predicate to the subquery, that is select * from customer where c_custkey not in ( select o_custkey from orders where o_custkey is not null ) Rewrite the NOT IN subquery to the not exists subquery, that is select * from customer where not exists ( select o_custkey from orders where o_custkey = c_custkey ) Note : PawSQL Advisor adopts the first method to do rewrite optimization, but it is more powerful, PawSQL Advisor first determines whether the columns in the subquery may be empty, and if it is possible, it will recommend the rewritten SQL to the user.","title":"3. NOT IN with NULL"},{"location":"blog/2022/four_pitfalls_null_processing/#4-all-subquery-with-null","text":"Conclusion : A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. Suppose we want to find out the orders which are wrongly registered after the user is revoked. One of solution is this following query statement. select * from customer where c_regdate > ALL ( select o_orderdate from orders where c_custkey = o_custkey ) Similar to NOT IN above, this sql does not return the expected result due to the presence of NULL in the result of the subquery. The ALL operation is actually performed by comparing it with the returned result set, and then performing the AND operation, and the final result is unknown . While unknown as a condition to be evaluated is, the result is false . There are two ways to correct it: Add a NOT NULL predicate to the subquery, select * from customer where c_regdate > all ( select o_orderdate from orders where o_orderdate is not null ) Rewrite expr > all to aggregate scalar subquery expr > (select max()...) 2 select * from customer where c_regdate > ( select max ( o_custkey ) from orders ) Note : PawSQL Advisor adopts the second way to rewrite optimization, because PawSQL Advisor can further optimize the performance of the second rewritten SQL by rewriting ('max/min subquery rewrite rule').","title":"4. ALL Subquery with NULL"},{"location":"blog/2022/four_pitfalls_null_processing/#null-optimization-in-pawsql-advisor","text":"PawSQL Advisor has three rewrite optimization rules for NULL processing, corresponding to the four cases above. RuleCode Rule Description UseEqual4NullRewrite expr = null or case expr when null can't determine whether the expr is null , is null should be used NotInNullableSubQueryRewrite A predicate of a not in subquery with nullable select elements will always be evaluated to false. AllQualifierSubQueryRewrite A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. PawSQL Advisor is more powerful, it will be based on whether the definition of a column in the DDL is nullable, and whether the operation on the column will produce nullable results, to determine whether the query column in the subquery is nullable, if it is possible to be empty, it will recommend the rewritten SQL to the user. Logic of NotInNullableSubQueryRewrite iterate parse tree of input query \uff0c retrieve all the NOT IN predicate for each NOT IN predicate { if the predicate is PredicateInValueSelect ( ` expr not in ( select ....) ` ){ check whether result set of subquery is nullable if no \uff0c return ; if yes \uff0c for each nullabe SELECT element ( rc ){ check whether there is a predicate ` rc is not null ` in the subquery if no \uff0c create a predicate ` rc is not null ` and combine with the conditions of WHERE clause in the sub query ; if yes \uff0c continue ; } } if the predicate is PredicateInValueList ( ` expr not in values ( 1 , 2 , null ) ` ) for each value in the value list if the value is NULL \uff0c delete it } Logic of checking whether result set of subquery is nullable isNullable ( SELECT expr ){ if ( expr is column of a table ) { if ( column is defined nullable ) return true ; else return true ; } else if ( expr is NULL ) { return true ; } else if ( expr is constant of variable ) { return false ; } else if ( expr is a combined expr ){ return ( arg1 || arg2 || ...); } else if ( expr is a function ) { if ( the function is one of ( \"SUM\" , \"Count\" , \"AVG\" )) return false ; else return isNullable ( arguements of the function ) } else if ( expr is SSQ ) { return isNullable ( SELECT expr of the SSQ ) } else { return true ; } }","title":"NULL Optimization in PawSQL Advisor"},{"location":"blog/2022/four_pitfalls_null_processing/#examination-of-the-pawsql-advisor-regarding-to-null-processing","text":"Sever cases of NULL handling are demonstrated. The columns c_phone and c_nationkey in the customer table definition are nullable. -- Case 1: = null rewritten to is null select count ( * ) from customer where c_phone = null ; -- Case 2: case expr when null is rewritten to case when expr is null select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer where not c_phone = null ; -- Case 3: c_nationkey nullable, increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Case 4: c_nationkey nullable, so max(c_nationkey) is nullable, increasing the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Case 5: count()/sum() is never empty, so there is no need to rewrite it select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Case 6: c_name is not null, but c_nationkey nullable, so you need to increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); -- Case 7: c_nationkey is nullable, so it is rewritten as > (select min(c_nationkey) from customer) select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer );","title":"Examination of The PawSQL Advisor regarding to NULL processing"},{"location":"blog/2022/four_pitfalls_null_processing/#pawsql-advisor-output-summary","text":"/********************************************************************\\ * * * PawSQL Optimization Summary * * * * Powered by PawSQL(2021- ) * * * \\********************************************************************/ 1 . Optimization Summary - There are 7 query analyzed ; - There are 6 optimization rewrites for 6 queries ; - There are 9 violations of optimization rule against 6 queries ; - There are 1 indices recommended for 4 queries ; - There is 12 . 91 % performance improvement . 2 . Optimization Rule Violations - RuleUseEqual4Null : [ null . sql - stmt2 , null . sql - stmt1 ] - RuleAllQualifierSubQueryRewrite : [ null . sql - stmt7 ] - RuleNoCond4NonAggSelect : [ null . sql - stmt3 , null . sql - stmt6 , null . sql - stmt7 ] - RuleNotInNullableSubQueryRewrite : [ null . sql - stmt4 , null . sql - stmt3 , null . sql - stmt6 ] ...","title":"PawSQL Advisor Output (Summary)"},{"location":"blog/2022/four_pitfalls_null_processing/#pawsql-advisor-output-single-sql-details","text":"Case 1: = null rewritten to is null -- Original SQL select count ( * ) from customer where c_phone = null ; -- Rewritten SQL select count ( * ) from customer where customer . c_phone is null ; Case 2: case expr when null rewritten as case when expr is null -- Original SQL select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer ; -- Rewritten SQL select case when c_phone is null then 1 when c_phone = '139%' then 0 else - 1 end from customer ; Case 3: c_nationkey is nullable, add the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer where c_nationkey is not null ) Case 4: c_nationkey is nullable, so max(c_nationkey) is nullable, adding the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select max ( customer . c_nationkey ) from customer where c_nationkey is not null group by c_mktsegment ) Case 5: count(c_nationkey) is never empty, so there is no need to rewrite it. select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); Case 6: c_name is not empty, but c_nationkey is nullable, so the c_nationkey is not null condition needs to be added. -- Original SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer where customer . c_nationkey is not null ) Case 7: c_nationkey is nullable, so rewritten as > (select min(c_nationkey) from customer) -- Original SQL select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from customer where n_nationkey > ( select min ( c_nationkey ) from customer ) https://en.wikipedia.org/wiki/Three-valued_logic \u21a9 If expr < all or expr < = all , then rewrite it as expr < (select min() ...) \u21a9","title":"PawSQL Advisor Output (single SQL details)"},{"location":"blog/2022/top5_sql_optimization_tools/","text":"Top 5 SQL Optimization Tools \u00b6 The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. ![ @pawsql ][ @pawsql avatar] Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 5 min read\u00b7 List of the top 5 SQL optimization tools \u00b6 SolarWinds Database Performance Analyzer Toad SQL Optimizer for Oracle EverSQL Query Optimizer PawSQL Advisor SQL tuning Here are the details on the pros and cons of each tool: SolarWinds Database Performance Analyzer \u00b6 Pros: Azure SQL databases, MySQL, Aurora, ASE, Oracle, MariaDB, and IBM Db2 supported Full-featured SQL query optimization tool On-going Performance insights Configuration tunning Cons: Weak query tuning More like finding the performance problems instead of solving them. Price: 14-day free trial , starts at $1,995 Toad SQL Optimizer for Oracle \u00b6 Pros: a part of an excellent suite for DBAs Query execution plan visualization Identify slow queries Inspect System Global Area (SGA) Cons: Only Oracle supported Designed for DBAs, too complicated for engineers without DBA skills Requires local installation Price: 14-days Free trial, Starts at $1,164 EverSQL ** \u00b6 Pros: Automatic SQL rewrite Supports MySQL, PostgreSQL, MariaDB, Percona, SQL Server, Cloud SQL, Aurora No installation required Missing indexes recommendations Machine learning algorithms On-going Performance insights Friendly for Software Developers Cons: Recommendations are not verified; the example rewrite is no good for performance. Some indexes recommended are not used. Price: Free for basic usage , one optimization a month. Advanced edition starts at $75. PawSQL Advisor \u00b6 Pros: Rules-based SQL auditing Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Powerful and intelligent index recommendation What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Cons: Only available as a plugin on Intellij based tools, such as IntelliJ IDEA, CLion, PyCharm Only support MySQL, PostgreSQL and derivatives, such as Opengauss, Maria Price: Free for now, no pricing policy announced SQL tuning \u00b6 Pros: On-line, no installation required Cons: Only Oracle support The software is sometimes buggy, some users report non-relevant recommendations Very basic, provides general recommendations Doesn't offer rewritten query Price: Free","title":"Top 5 SQL Optimization Tools"},{"location":"blog/2022/top5_sql_optimization_tools/#top-5-sql-optimization-tools","text":"The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. ![ @pawsql ][ @pawsql avatar] Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 5 min read\u00b7","title":"Top 5 SQL Optimization Tools"},{"location":"blog/2022/top5_sql_optimization_tools/#list-of-the-top-5-sql-optimization-tools","text":"SolarWinds Database Performance Analyzer Toad SQL Optimizer for Oracle EverSQL Query Optimizer PawSQL Advisor SQL tuning Here are the details on the pros and cons of each tool:","title":"List of the top 5 SQL optimization tools"},{"location":"blog/2022/top5_sql_optimization_tools/#solarwinds-database-performance-analyzer","text":"Pros: Azure SQL databases, MySQL, Aurora, ASE, Oracle, MariaDB, and IBM Db2 supported Full-featured SQL query optimization tool On-going Performance insights Configuration tunning Cons: Weak query tuning More like finding the performance problems instead of solving them. Price: 14-day free trial , starts at $1,995","title":"SolarWinds Database Performance Analyzer"},{"location":"blog/2022/top5_sql_optimization_tools/#toad-sql-optimizer-for-oracle","text":"Pros: a part of an excellent suite for DBAs Query execution plan visualization Identify slow queries Inspect System Global Area (SGA) Cons: Only Oracle supported Designed for DBAs, too complicated for engineers without DBA skills Requires local installation Price: 14-days Free trial, Starts at $1,164","title":"Toad SQL Optimizer for Oracle"},{"location":"blog/2022/top5_sql_optimization_tools/#eversql","text":"Pros: Automatic SQL rewrite Supports MySQL, PostgreSQL, MariaDB, Percona, SQL Server, Cloud SQL, Aurora No installation required Missing indexes recommendations Machine learning algorithms On-going Performance insights Friendly for Software Developers Cons: Recommendations are not verified; the example rewrite is no good for performance. Some indexes recommended are not used. Price: Free for basic usage , one optimization a month. Advanced edition starts at $75.","title":"EverSQL**"},{"location":"blog/2022/top5_sql_optimization_tools/#pawsql-advisor","text":"Pros: Rules-based SQL auditing Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Powerful and intelligent index recommendation What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Cons: Only available as a plugin on Intellij based tools, such as IntelliJ IDEA, CLion, PyCharm Only support MySQL, PostgreSQL and derivatives, such as Opengauss, Maria Price: Free for now, no pricing policy announced","title":"PawSQL  Advisor"},{"location":"blog/2022/top5_sql_optimization_tools/#sql-tuning","text":"Pros: On-line, no installation required Cons: Only Oracle support The software is sometimes buggy, some users report non-relevant recommendations Very basic, provides general recommendations Doesn't offer rewritten query Price: Free","title":"SQL tuning"},{"location":"pawcloud/introduction/","text":"PawSQL Cloud User Guide \u00b6 Introduction \u00b6 PawSQL Cloud is the cloud version of PawSQL Advisor, and now it's generally available for \u03b2 users at https://app.pawsql.com . Features\u00b6 \u00b6 Rules-based SQL auditing, targeting correctness auditing and performance optimization. Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation, based on input SQL syntax, database objects and statistics information. What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Concepts in PawSQL Cloud \u00b6 A Workspace is the environment(tables, views, indexes, and associated statistics) you want to do the query optimization against. A Workload is a single DML SQL statement or a set of DML SQL statements you want to optimize and analyze. A Optimization is an operation you define and PawSQL performs to optimize a workload against a workspace. Three Steps to set up an optimization \u00b6 Create a workspace Input the SQLs(a workload) to be optimized Setup a optimization Step 1. Create a workspace PawSQL Cloud supports creating a workspace in the following ways: By database connection information: supports databases such as MySQL, PostgreSQL, Opengauss, and MariaDB. By uploading a DDL file By manually inputting DDL text. Hint : For each method of creating a workspace, PawSQL provides online guides to help you set up your workspace on the right half. Step 2. Input the SQLs(a workload) The source of the SQL to be optimized can be: Database SQL log (supporting MySQL slow log/general log, PostgreSQL SQL log, opengauss SQL log) A text file composed of SQL statements separated by ; SQL statements manually inputted into a text box separated by ; Note: You can also see that PawSQL provides an online guide to help you obtain the SQL to be optimized. Step 3. Set up an optimization You can configure your query optimization to control the execution process and results of your query optimization. Basic Configuration: Optimization ID: Identifies your optimization ID for this optimization session. Execution Configuration: Dedup with Existing Indexes: Whether to deduplicate with existing indexes. Perform What-if Verification: Whether to connect to a verification server to validate the performance of the optimization results. Rule Configuration: Enable the optimization rule. Explain the output \u00b6 Optimization Summary \u00b6 The summary results display includes: Number of executed SQLs Number of rewrote optimizations Number of SQL auditing rule violations Recommended indexes Overview of individual SQL optimization Optimization Details \u00b6 For each SQL query, PawSQL will provide optimization details to show you WHAT* and ***HOW** the query is tuned, HOW MUCH* does its performance improve and etc. There are ***FIVE** sections in this query level tuning details, as follows. Original SQL: The original SQL statement you are optimizing. Rewritten SQL (if any): If the SQL statement has been rewritten, this shows the rewritten SQL statement. Recommended Index (if any): If there is a suggested index, the details of the index are displayed here. Validation Details (if what-if validation is set): If what-if validation is performed, this shows the details of the validation, including: Performance improvement percentage: The percentage difference in performance between the optimized and unoptimized SQL statements. Execution plan before optimization: The execution plan of the SQL statement before optimization. Execution plan after optimization: The execution plan of the SQL statement after optimization. Contact us \u00b6 Website: https://docs.pawsql.com Twitter: https://twitter.com/pawsql Email: service@pawsql.com WeChat: especially for complex queries, the rewrite feature is very sophisticated and the index advice is also very powerful.","title":"PawSQL Cloud"},{"location":"pawcloud/introduction/#pawsql-cloud-user-guide","text":"","title":"PawSQL Cloud User Guide"},{"location":"pawcloud/introduction/#introduction","text":"PawSQL Cloud is the cloud version of PawSQL Advisor, and now it's generally available for \u03b2 users at https://app.pawsql.com .","title":"Introduction"},{"location":"pawcloud/introduction/#features","text":"Rules-based SQL auditing, targeting correctness auditing and performance optimization. Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation, based on input SQL syntax, database objects and statistics information. What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations.","title":"Features\u00b6"},{"location":"pawcloud/introduction/#concepts-in-pawsql-cloud","text":"A Workspace is the environment(tables, views, indexes, and associated statistics) you want to do the query optimization against. A Workload is a single DML SQL statement or a set of DML SQL statements you want to optimize and analyze. A Optimization is an operation you define and PawSQL performs to optimize a workload against a workspace.","title":"Concepts in PawSQL Cloud"},{"location":"pawcloud/introduction/#three-steps-to-set-up-an-optimization","text":"Create a workspace Input the SQLs(a workload) to be optimized Setup a optimization Step 1. Create a workspace PawSQL Cloud supports creating a workspace in the following ways: By database connection information: supports databases such as MySQL, PostgreSQL, Opengauss, and MariaDB. By uploading a DDL file By manually inputting DDL text. Hint : For each method of creating a workspace, PawSQL provides online guides to help you set up your workspace on the right half. Step 2. Input the SQLs(a workload) The source of the SQL to be optimized can be: Database SQL log (supporting MySQL slow log/general log, PostgreSQL SQL log, opengauss SQL log) A text file composed of SQL statements separated by ; SQL statements manually inputted into a text box separated by ; Note: You can also see that PawSQL provides an online guide to help you obtain the SQL to be optimized. Step 3. Set up an optimization You can configure your query optimization to control the execution process and results of your query optimization. Basic Configuration: Optimization ID: Identifies your optimization ID for this optimization session. Execution Configuration: Dedup with Existing Indexes: Whether to deduplicate with existing indexes. Perform What-if Verification: Whether to connect to a verification server to validate the performance of the optimization results. Rule Configuration: Enable the optimization rule.","title":"Three Steps to set up an optimization"},{"location":"pawcloud/introduction/#explain-the-output","text":"","title":"Explain the output"},{"location":"pawcloud/introduction/#optimization-summary","text":"The summary results display includes: Number of executed SQLs Number of rewrote optimizations Number of SQL auditing rule violations Recommended indexes Overview of individual SQL optimization","title":"Optimization Summary"},{"location":"pawcloud/introduction/#optimization-details","text":"For each SQL query, PawSQL will provide optimization details to show you WHAT* and ***HOW** the query is tuned, HOW MUCH* does its performance improve and etc. There are ***FIVE** sections in this query level tuning details, as follows. Original SQL: The original SQL statement you are optimizing. Rewritten SQL (if any): If the SQL statement has been rewritten, this shows the rewritten SQL statement. Recommended Index (if any): If there is a suggested index, the details of the index are displayed here. Validation Details (if what-if validation is set): If what-if validation is performed, this shows the details of the validation, including: Performance improvement percentage: The percentage difference in performance between the optimized and unoptimized SQL statements. Execution plan before optimization: The execution plan of the SQL statement before optimization. Execution plan after optimization: The execution plan of the SQL statement after optimization.","title":"Optimization Details"},{"location":"pawcloud/introduction/#contact-us","text":"Website: https://docs.pawsql.com Twitter: https://twitter.com/pawsql Email: service@pawsql.com WeChat: especially for complex queries, the rewrite feature is very sophisticated and the index advice is also very powerful.","title":"Contact us"},{"location":"pawindexadvisor/","text":"What is Paw Index Advisor? \u00b6 Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if analysis , make sure indexes recommended be used in later query execution Get started \u00b6 Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter \"Paw Index Advisor\" in martketplace and click install Configure the running parameters of PawSQL Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for a minute and recommended indexes will be presented to you to accelerate your database queries. Claim: Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started with Paw Index Advisor"},{"location":"pawindexadvisor/#what-is-paw-index-advisor","text":"Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"What is Paw Index Advisor?"},{"location":"pawindexadvisor/#features","text":"Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if analysis , make sure indexes recommended be used in later query execution","title":"Features"},{"location":"pawindexadvisor/#get-started","text":"Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter \"Paw Index Advisor\" in martketplace and click install Configure the running parameters of PawSQL Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for a minute and recommended indexes will be presented to you to accelerate your database queries. Claim: Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started"},{"location":"pawindexadvisor/change-log/","text":"Changelog \u00b6 0.1.109 _ August 15, 2022 \u00b6 Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue. 0.1.108 _ August 10, 2022 \u00b6 Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12. 0.1.106 _ August 10, 2022 \u00b6 Initial beta release.","title":"Changelog"},{"location":"pawindexadvisor/change-log/#changelog","text":"","title":"Changelog"},{"location":"pawindexadvisor/change-log/#0.1.109","text":"Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue.","title":"0.1.109 _ August 15, 2022"},{"location":"pawindexadvisor/change-log/#0.1.108","text":"Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12.","title":"0.1.108 _ August 10, 2022"},{"location":"pawindexadvisor/change-log/#0.1.106","text":"Initial beta release.","title":"0.1.106 _ August 10, 2022"},{"location":"pawindexadvisor/command-line/","text":"Command Line \u00b6 For database administrators, they can use Paw Index Advisor in a command line way, which gives the user more control how the tool behave, comparing with the plugin way. Prerequisites \u00b6 JRE 1.8 or above OS: Windows + Linux+Mac OS Command \u00b6 $ java -jar paw-indexadvisor.jar -c config/config.properties Configuration \u00b6 The input and parameters needed for Paw Index Advisor to work are defined in the configuration file config/config.properties . config.properties \u00b6 # The configuration file for index advisor # config the workload sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases sqllab.mapperfolder = ./tpch/mappers # config the ddl sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ sqllab.statsmode = offline sqllab.statsfolder = ./tpch/stats # server info for online retrieve dbobjects/stats and for what-if analysis sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch # config the output directory sqllab.resultfolder = ./tpch/out/index.sql # whether de-duplicate with existing indexes sqllab.ia.dedupflag = true # whether what-if validation sqllab.ia.validate = true","title":"Command Line"},{"location":"pawindexadvisor/command-line/#command-line","text":"For database administrators, they can use Paw Index Advisor in a command line way, which gives the user more control how the tool behave, comparing with the plugin way.","title":"Command Line"},{"location":"pawindexadvisor/command-line/#prerequisites","text":"JRE 1.8 or above OS: Windows + Linux+Mac OS","title":"Prerequisites"},{"location":"pawindexadvisor/command-line/#command","text":"$ java -jar paw-indexadvisor.jar -c config/config.properties","title":"Command"},{"location":"pawindexadvisor/command-line/#configuration","text":"The input and parameters needed for Paw Index Advisor to work are defined in the configuration file config/config.properties .","title":"Configuration"},{"location":"pawindexadvisor/command-line/#configproperties","text":"# The configuration file for index advisor # config the workload sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases sqllab.mapperfolder = ./tpch/mappers # config the ddl sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ sqllab.statsmode = offline sqllab.statsfolder = ./tpch/stats # server info for online retrieve dbobjects/stats and for what-if analysis sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch # config the output directory sqllab.resultfolder = ./tpch/out/index.sql # whether de-duplicate with existing indexes sqllab.ia.dedupflag = true # whether what-if validation sqllab.ia.validate = true","title":"config.properties"},{"location":"pawindexadvisor/configuration/","text":"Configuration \u00b6 You can configure and control the execution process on the Paw Index Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation Query Type \u00b6 Specifies the type of input SQL statements. Paw Index Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, Paw Index Advisor will parse those file and permutes all possible SQL combinations. Paw Index Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some of the combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog. Database Vendor \u00b6 Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested. Connection Info \u00b6 Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance. Database host \u00b6 Ip address or host name of the database server Database port \u00b6 Port of the connection to the database server User \u00b6 User name to connect to the database server Password \u00b6 The password of the user connecting to the database server DefaultDB \u00b6 The default database name when connecting to the database server Database/schema List \u00b6 For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b Deduplicate with existing indexes \u00b6 If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index. What-if analysis validation \u00b6 If this option is checked, Paw Index Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), Paw Index Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"Configuration"},{"location":"pawindexadvisor/configuration/#configuration","text":"You can configure and control the execution process on the Paw Index Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation","title":"Configuration"},{"location":"pawindexadvisor/configuration/#query-type","text":"Specifies the type of input SQL statements. Paw Index Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, Paw Index Advisor will parse those file and permutes all possible SQL combinations. Paw Index Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some of the combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog.","title":"Query Type"},{"location":"pawindexadvisor/configuration/#database-vendor","text":"Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested.","title":"Database Vendor"},{"location":"pawindexadvisor/configuration/#connection-info","text":"Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance.","title":"Connection Info"},{"location":"pawindexadvisor/configuration/#database-host","text":"Ip address or host name of the database server","title":"Database host"},{"location":"pawindexadvisor/configuration/#database-port","text":"Port of the connection to the database server","title":"Database port"},{"location":"pawindexadvisor/configuration/#user","text":"User name to connect to the database server","title":"User"},{"location":"pawindexadvisor/configuration/#password","text":"The password of the user connecting to the database server","title":"Password"},{"location":"pawindexadvisor/configuration/#defaultdb","text":"The default database name when connecting to the database server","title":"DefaultDB"},{"location":"pawindexadvisor/configuration/#databaseschema-list","text":"For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b","title":"Database/schema List"},{"location":"pawindexadvisor/configuration/#deduplicate-with-existing-indexes","text":"If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index.","title":"Deduplicate with existing indexes"},{"location":"pawindexadvisor/configuration/#what-if-analysis-validation","text":"If this option is checked, Paw Index Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), Paw Index Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"What-if analysis validation"},{"location":"pawindexadvisor/configuration2/","text":"Configuration \u00b6 You can configure the input, output and control the execution process either in config.properties file in the command line mode, or on the Configuration page when you are using the Paw Index Advisor plugin. Configure Db-objects \u00b6 The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names in the SQL statements to be optimized, and they will be use in following query rewrite optimization and index recommendation. Command Line IntelliJ Plugin Property sqllab.ddlmode is used to define how and what database objects(relation table definitions and indexes definitions) are use for the Paw Index Advisor to execute against. If offline mode is set\uff0c sqllab.ddlfolder should be specified to define which directory should be look up within. sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ If online mode is set\uff0c sqllab.server parameters should be specified, MySQL and PostgreSQL and derivatives, such as opengauss, maria are supported\u3002 sqllab.ddlmode = online sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch There is only the online option if your use Paw Index Advisor plugin, and you need to fill sql.server fields. Configure Queries \u00b6 The next step is to specify the input queries to optimize. Command Line IntelliJ Plugin Property sqllab.querymode is used to define how and what query statements to be analyzed and optimized. When offline mode is set\uff0c sqllab.queryfolder should be specified to define which directory should be looked within. sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases When mapper mode is set\uff0c\uff0c sqllab.mapperfolder should be specified sqllab.querymode = mapper sqllab.mapperfolder = ./tpch/mappers If you are using Paw Index Advisor plugin, the input queries to optimize is the sql file you right clicked on or the sql files under the directory you right clicked on in the IDEA on which the Paw Index Advisor plugin is installed. Configure Output \u00b6 There are two result files generated, %paw_index.sql and %paw_index_what_if.txt . You can specify where they will be placed into. Command Line IntelliJ Plugin Property sqllab.resultfolder is used to specify which directory the recommended indexes will be placed into. And the validation details will be under the same directory with a name postfixed with what-if . sqllab.resultfolder = ./tpch/out/index.sql If you are using Paw Index Advisor plugin, you needn't specify the output directory. If you analyze a sql file named filename.sql , the output files will be filename_paw_index.sql and filename_paw_index_what_if.txt under the same directory. If you analyze sql files under a directory directoryname , the output files will be paw_index.sql and paw_index_what_if.txt under the directory directoryname . Configure Execution \u00b6 You can control the execution process by configure execution parameters. De-duplicate with existing indexes \u00b6 If this parameter is set to true, the Paw Index Advisor will de-duplicate the candidate indexes with existing indexes. The process will adhere to the leftmost matching rule. Command Line IntelliJ Plugin sqllab.ia.dedupflag = true Check the check-box in the Index Advisor Configuration page. What-if validation \u00b6 If this parameter is set to true, the database connection information must be set correctly. The Paw Index Advisor will do an extra what-if validation phase against database and only indexes which contribute the performance improvement will be recommended. Command Line IntelliJ Plugin sqllab.ia.validate = true Check the check-box in the Index Advisor Configuration page.","title":"Configuration"},{"location":"pawindexadvisor/configuration2/#configuration","text":"You can configure the input, output and control the execution process either in config.properties file in the command line mode, or on the Configuration page when you are using the Paw Index Advisor plugin.","title":"Configuration"},{"location":"pawindexadvisor/configuration2/#configure-db-objects","text":"The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names in the SQL statements to be optimized, and they will be use in following query rewrite optimization and index recommendation. Command Line IntelliJ Plugin Property sqllab.ddlmode is used to define how and what database objects(relation table definitions and indexes definitions) are use for the Paw Index Advisor to execute against. If offline mode is set\uff0c sqllab.ddlfolder should be specified to define which directory should be look up within. sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ If online mode is set\uff0c sqllab.server parameters should be specified, MySQL and PostgreSQL and derivatives, such as opengauss, maria are supported\u3002 sqllab.ddlmode = online sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch There is only the online option if your use Paw Index Advisor plugin, and you need to fill sql.server fields.","title":"Configure Db-objects"},{"location":"pawindexadvisor/configuration2/#configure-queries","text":"The next step is to specify the input queries to optimize. Command Line IntelliJ Plugin Property sqllab.querymode is used to define how and what query statements to be analyzed and optimized. When offline mode is set\uff0c sqllab.queryfolder should be specified to define which directory should be looked within. sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases When mapper mode is set\uff0c\uff0c sqllab.mapperfolder should be specified sqllab.querymode = mapper sqllab.mapperfolder = ./tpch/mappers If you are using Paw Index Advisor plugin, the input queries to optimize is the sql file you right clicked on or the sql files under the directory you right clicked on in the IDEA on which the Paw Index Advisor plugin is installed.","title":"Configure Queries"},{"location":"pawindexadvisor/configuration2/#configure-output","text":"There are two result files generated, %paw_index.sql and %paw_index_what_if.txt . You can specify where they will be placed into. Command Line IntelliJ Plugin Property sqllab.resultfolder is used to specify which directory the recommended indexes will be placed into. And the validation details will be under the same directory with a name postfixed with what-if . sqllab.resultfolder = ./tpch/out/index.sql If you are using Paw Index Advisor plugin, you needn't specify the output directory. If you analyze a sql file named filename.sql , the output files will be filename_paw_index.sql and filename_paw_index_what_if.txt under the same directory. If you analyze sql files under a directory directoryname , the output files will be paw_index.sql and paw_index_what_if.txt under the directory directoryname .","title":"Configure Output"},{"location":"pawindexadvisor/configuration2/#configure-execution","text":"You can control the execution process by configure execution parameters.","title":"Configure Execution"},{"location":"pawindexadvisor/configuration2/#de-duplicate-with-existing-indexes","text":"If this parameter is set to true, the Paw Index Advisor will de-duplicate the candidate indexes with existing indexes. The process will adhere to the leftmost matching rule. Command Line IntelliJ Plugin sqllab.ia.dedupflag = true Check the check-box in the Index Advisor Configuration page.","title":"De-duplicate with existing indexes"},{"location":"pawindexadvisor/configuration2/#what-if-validation","text":"If this parameter is set to true, the database connection information must be set correctly. The Paw Index Advisor will do an extra what-if validation phase against database and only indexes which contribute the performance improvement will be recommended. Command Line IntelliJ Plugin sqllab.ia.validate = true Check the check-box in the Index Advisor Configuration page.","title":"What-if validation"},{"location":"pawindexadvisor/eula/","text":"End-User License Agreement (EULA) of Paw Index Advisor \u00b6 This EULA agreement governs your acquisition and use of our Paw Index Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the Paw Index Advisor software. It provides a license to use the Paw Index Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the Paw Index Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Paw Index Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant \u00b6 Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the Paw Index Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Paw Index Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Paw Index Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement Intellectual Property and Ownership \u00b6 Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties. Termination \u00b6 This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL. Governing Law \u00b6 This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"End-User License Agreement (EULA) of Paw Index Advisor"},{"location":"pawindexadvisor/eula/#end-user-license-agreement-eula-of-paw-index-advisor","text":"This EULA agreement governs your acquisition and use of our Paw Index Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the Paw Index Advisor software. It provides a license to use the Paw Index Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the Paw Index Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Paw Index Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of Paw Index Advisor"},{"location":"pawindexadvisor/eula/#license-grant","text":"Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the Paw Index Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Paw Index Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Paw Index Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement","title":"License Grant"},{"location":"pawindexadvisor/eula/#intellectual-property-and-ownership","text":"Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"pawindexadvisor/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL.","title":"Termination"},{"location":"pawindexadvisor/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"Governing Law"},{"location":"pawindexadvisor/intellij-plugin/","text":"IntelliJ Plugin \u00b6 Paw Index Advisor is integrated into most popular IDEs, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm and Eclipse, Spring Tool Suite. For application developers, they can optimize the application performance by One Click . Steps: Install a compatible JetBrains IDE, such as IntelliJ IDEA, CLion, PyCharm, or other IntelliJ-based IDEs. Launch the IDE and open plugin settings Search for \"Paw Index Advisor\" in martketplace and click install Configure the query type and database information on the configuration page Right click any folder which contains the sql statments/mybatis xml files, and click \"Run Index Advisor\" Wait for a minute and indexes are recommended to accelerate your database queries. Installation \u00b6 Method 1: Search for \"Paw Index Advisor\" in marketplace and click install( Prefer ). Method 2: you can visit the \"Paw Index Advisor\" plugin page at https://plugins.jetbrains.com/plugin/19003-paw-index-advisor , and install it from that page or download the plugin and install it from disk later. Configuration \u00b6 Configure the input and execution parameters in the Project Setting panel. See details at Configure the Index Advisor Run by One Click \u00b6 Right click on a SQL/mybatis xml file or any folder which contains the sql statements/mybatis xml files, and click \"Run Index Advisor\". You can see the analysis is started on the PawSQL console. Get recommendation \u00b6 After the analysis is done, the recommendation result file named paw_index.sql is opened for you, and you can also find the validation details in the paw_index_what-if.txt file. You can decided whether to apply those recommendation according to the validation details of queries. You can find the details about how to interpret the output at Explain the Output .","title":"IntelliJ Plugin"},{"location":"pawindexadvisor/intellij-plugin/#intellij-plugin","text":"Paw Index Advisor is integrated into most popular IDEs, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm and Eclipse, Spring Tool Suite. For application developers, they can optimize the application performance by One Click . Steps: Install a compatible JetBrains IDE, such as IntelliJ IDEA, CLion, PyCharm, or other IntelliJ-based IDEs. Launch the IDE and open plugin settings Search for \"Paw Index Advisor\" in martketplace and click install Configure the query type and database information on the configuration page Right click any folder which contains the sql statments/mybatis xml files, and click \"Run Index Advisor\" Wait for a minute and indexes are recommended to accelerate your database queries.","title":"IntelliJ Plugin"},{"location":"pawindexadvisor/intellij-plugin/#installation","text":"Method 1: Search for \"Paw Index Advisor\" in marketplace and click install( Prefer ). Method 2: you can visit the \"Paw Index Advisor\" plugin page at https://plugins.jetbrains.com/plugin/19003-paw-index-advisor , and install it from that page or download the plugin and install it from disk later.","title":"Installation"},{"location":"pawindexadvisor/intellij-plugin/#configuration","text":"Configure the input and execution parameters in the Project Setting panel. See details at Configure the Index Advisor","title":"Configuration"},{"location":"pawindexadvisor/intellij-plugin/#run-by-one-click","text":"Right click on a SQL/mybatis xml file or any folder which contains the sql statements/mybatis xml files, and click \"Run Index Advisor\". You can see the analysis is started on the PawSQL console.","title":"Run by One Click"},{"location":"pawindexadvisor/intellij-plugin/#get-recommendation","text":"After the analysis is done, the recommendation result file named paw_index.sql is opened for you, and you can also find the validation details in the paw_index_what-if.txt file. You can decided whether to apply those recommendation according to the validation details of queries. You can find the details about how to interpret the output at Explain the Output .","title":"Get recommendation"},{"location":"pawindexadvisor/recommended-indexes/","text":"Indexes Recommended \u00b6 After the recommending indexes process is done, there will be two result files generated in the directory of optimized input queries, one is the summary file paw_index.sql and the other is the validation details file paw_index_what_if.txt , outlined as follows: . \u2514\u2500 file1.sql \u2514\u2500 file2.sql \u2514\u2500 paw_index.sql \u2514\u2500 paw_index_what_if.txt Recommendation Summary \u00b6 The summary file paw_index.sql contains following three section of inforamtion Existing Indexes \u00b6 This section contains the existing indexes of tables referenced in the input SQL queries. Those tables may not used in the query execution and can be dropped later. -- Existing indexes CREATE INDEX CUSTOMER_C_NATIONKEY_FKEY ON CUSTOMER ( C_NATIONKEY ); CREATE INDEX CUSTOMER_PKEY ON CUSTOMER ( C_CUSTKEY ); CREATE INDEX MYINDEX ON CUSTOMER ( C_NAME , C_PHONE ); CREATE INDEX LINEITEM_L_ORDERKEY_FKEY ON LINEITEM ( L_ORDERKEY ); CREATE INDEX LINEITEM_L_PARTKEY_L_SUPPKEY_FKEY ON LINEITEM ( L_SUPPKEY , L_PARTKEY ); CREATE INDEX LINEITEM_PKEY ON LINEITEM ( L_ORDERKEY , L_LINENUMBER ); CREATE INDEX NATION_N_REGIONKEY_FKEY ON NATION ( N_REGIONKEY ); CREATE INDEX NATION_PKEY ON NATION ( N_NATIONKEY ); CREATE INDEX ORDERS_O_CUSTKEY_FKEY ON ORDERS ( O_CUSTKEY ); CREATE INDEX ORDERS_PKEY ON ORDERS ( O_ORDERKEY ); CREATE INDEX PART_PKEY ON PART ( P_PARTKEY ); CREATE INDEX PARTSUPP_PKEY ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_PARTKEY_FKEY ON PARTSUPP ( PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_SUPPKEY_FKEY ON PARTSUPP ( PS_SUPPKEY ); CREATE INDEX REGION_PKEY ON REGION ( R_REGIONKEY ); CREATE INDEX SUPPLIER_PKEY ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SUPPLIER_S_NATIONKEY_FKEY ON SUPPLIER ( S_NATIONKEY ); Indexes Recommended (before validation) \u00b6 This section contains the list of candidate indexes before the what-if validation. If the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 ; otherwise those candidate indexes only de-duplicate with themselves. -- Recommended indexes (After deduplication with existing indexes above) CREATE INDEX PAW_IDX1496549982 ON NATION ( N_NATIONKEY , N_NAME ); CREATE INDEX PAW_IDX1049412868 ON NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1968327707 ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY , PS_SUPPLYCOST ); CREATE INDEX PAW_IDX1794855777 ON PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX1400713053 ON PARTSUPP ( PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY , PS_PARTKEY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0306025125 ON PART ( P_NAME , P_PARTKEY ); CREATE INDEX PAW_IDX1038398061 ON PART ( P_PARTKEY , P_NAME ); ... Indexes Recommended (after validation) \u00b6 If the What-if analysis validation is checked, those indexes which are verified to gain performance improvement will be listed in this section. Otherwise, this section will be empty. -- After what-if analaysis validation CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); CREATE INDEX PAW_IDX0538538531 ON LINEITEM ( L_ORDERKEY , L_SUPPKEY ); CREATE INDEX PAW_IDX0607681583 ON LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0394351801 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_DISCOUNT , L_EXTENDEDPRICE ); ... The de-duplication alogrithm is adhere to left-most prefix principle. \u21a9","title":"Indexes Recommended"},{"location":"pawindexadvisor/recommended-indexes/#indexes-recommended","text":"After the recommending indexes process is done, there will be two result files generated in the directory of optimized input queries, one is the summary file paw_index.sql and the other is the validation details file paw_index_what_if.txt , outlined as follows: . \u2514\u2500 file1.sql \u2514\u2500 file2.sql \u2514\u2500 paw_index.sql \u2514\u2500 paw_index_what_if.txt","title":"Indexes Recommended"},{"location":"pawindexadvisor/recommended-indexes/#recommendation-summary","text":"The summary file paw_index.sql contains following three section of inforamtion","title":"Recommendation Summary"},{"location":"pawindexadvisor/recommended-indexes/#existing-indexes","text":"This section contains the existing indexes of tables referenced in the input SQL queries. Those tables may not used in the query execution and can be dropped later. -- Existing indexes CREATE INDEX CUSTOMER_C_NATIONKEY_FKEY ON CUSTOMER ( C_NATIONKEY ); CREATE INDEX CUSTOMER_PKEY ON CUSTOMER ( C_CUSTKEY ); CREATE INDEX MYINDEX ON CUSTOMER ( C_NAME , C_PHONE ); CREATE INDEX LINEITEM_L_ORDERKEY_FKEY ON LINEITEM ( L_ORDERKEY ); CREATE INDEX LINEITEM_L_PARTKEY_L_SUPPKEY_FKEY ON LINEITEM ( L_SUPPKEY , L_PARTKEY ); CREATE INDEX LINEITEM_PKEY ON LINEITEM ( L_ORDERKEY , L_LINENUMBER ); CREATE INDEX NATION_N_REGIONKEY_FKEY ON NATION ( N_REGIONKEY ); CREATE INDEX NATION_PKEY ON NATION ( N_NATIONKEY ); CREATE INDEX ORDERS_O_CUSTKEY_FKEY ON ORDERS ( O_CUSTKEY ); CREATE INDEX ORDERS_PKEY ON ORDERS ( O_ORDERKEY ); CREATE INDEX PART_PKEY ON PART ( P_PARTKEY ); CREATE INDEX PARTSUPP_PKEY ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_PARTKEY_FKEY ON PARTSUPP ( PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_SUPPKEY_FKEY ON PARTSUPP ( PS_SUPPKEY ); CREATE INDEX REGION_PKEY ON REGION ( R_REGIONKEY ); CREATE INDEX SUPPLIER_PKEY ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SUPPLIER_S_NATIONKEY_FKEY ON SUPPLIER ( S_NATIONKEY );","title":"Existing Indexes"},{"location":"pawindexadvisor/recommended-indexes/#indexes-recommended-before-validation","text":"This section contains the list of candidate indexes before the what-if validation. If the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 ; otherwise those candidate indexes only de-duplicate with themselves. -- Recommended indexes (After deduplication with existing indexes above) CREATE INDEX PAW_IDX1496549982 ON NATION ( N_NATIONKEY , N_NAME ); CREATE INDEX PAW_IDX1049412868 ON NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1968327707 ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY , PS_SUPPLYCOST ); CREATE INDEX PAW_IDX1794855777 ON PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX1400713053 ON PARTSUPP ( PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY , PS_PARTKEY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0306025125 ON PART ( P_NAME , P_PARTKEY ); CREATE INDEX PAW_IDX1038398061 ON PART ( P_PARTKEY , P_NAME ); ...","title":"Indexes Recommended (before validation)"},{"location":"pawindexadvisor/recommended-indexes/#indexes-recommended-after-validation","text":"If the What-if analysis validation is checked, those indexes which are verified to gain performance improvement will be listed in this section. Otherwise, this section will be empty. -- After what-if analaysis validation CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); CREATE INDEX PAW_IDX0538538531 ON LINEITEM ( L_ORDERKEY , L_SUPPKEY ); CREATE INDEX PAW_IDX0607681583 ON LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0394351801 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_DISCOUNT , L_EXTENDEDPRICE ); ... The de-duplication alogrithm is adhere to left-most prefix principle. \u21a9","title":"Indexes Recommended (after validation)"},{"location":"pawindexadvisor/what-if-validation/","text":"What-if Validation \u00b6 The other result file is the %paw_index_what_if.txt which explains how recommended indexes helps the analyzed queries. This result file is generated only when the What-if analysis validation option is enabled. This file contains a list of query's validation information. For each query, it reveals following information. Query ID \u00b6 The identification of the input query. It is a combinnation of input SQL file name and a \" stmt \" + ordinal of the SQL statement in the input SQL file. So the \" 17.sql-stmt1 \" means the first SQL statement in 17.sql file. - 17.sql-stmt1 -- query id Query Text \u00b6 The original query text which is analyzed and optimized to improve its performance. SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY ); Performance Improvement \u00b6 The performance improvement(pi) of the query named query id . The performance improvement is calculate according to the cost before and after recommended indexes virtually applied[^2]. - performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] The calculation formula for pi is pi = (cost_before - cost_after) / cost_after Cost Before \u00b6 The query cost before the recommended indexes are applied. Cost After \u00b6 The query cost after the recommended indexes are applied. Contributing Indexes \u00b6 The indexes contribute to the query execution, including the existing indexes and recommended indexes. - Contributing indice:[PAW_IDX1352615704, PAW_IDX0607681583, PAW_IDX1285498835] -- the indexes used paw_index_what-if.txt \u00b6 /****************************************************************\\ * * * Recommended Index Validation Details * * * * Powered by PawSQL(2022 - ) * * * \\****************************************************************/ -- Recommended indexes CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); ... -- Validation details -- 17.sql1, performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] Contributing indice :[ PAW_IDX1352615704 , PAW_IDX0607681583 , PAW_IDX1285498835 ] SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY ); -- 21.sql1, performance improves by 1173.2289478709183%[cost_before=1333.58,after_cost=104.74] Contributing indice :[ PAW_IDX1621082330 , PAW_IDX1003493942 , PAW_IDX1416165687 , IDX_LINEITEM_ORDERKEY , PAW_IDX0538538531 ] SELECT S_NAME , COUNT ( * ) AS NUMWAIT FROM SUPPLIER , LINEITEM L1 , ORDERS , NATION WHERE S_SUPPKEY = L1 . L_SUPPKEY AND O_ORDERKEY = L1 . L_ORDERKEY AND O_ORDERSTATUS = 'F' AND L1 . L_RECEIPTDATE > L1 . L_COMMITDATE AND EXISTS ( SELECT * FROM LINEITEM L2 WHERE L2 . L_ORDERKEY = L1 . L_ORDERKEY AND L2 . L_SUPPKEY <> L1 . L_SUPPKEY ) AND NOT EXISTS ( SELECT * FROM LINEITEM L3 WHERE L3 . L_ORDERKEY = L1 . L_ORDERKEY AND L3 . L_SUPPKEY <> L1 . L_SUPPKEY AND L3 . L_RECEIPTDATE > L3 . L_COMMITDATE ) AND S_NATIONKEY = N_NATIONKEY AND N_NAME = 'EGYPT' GROUP BY S_NAME ORDER BY NUMWAIT DESC , S_NAME LIMIT 100 ; -- 7.sql1, performance improves by 3877.8084714548804%[cost_before=863.98,after_cost=21.72] Contributing indice :[ PAW_IDX1264424863 , PAW_IDX1409884827 , PAW_IDX1017563074 , CUSTOMER_PKEY , PAW_IDX1640274034 , PAW_IDX1640274034 ] SELECT SUPP_NATION , CUST_NATION , L_YEAR , SUM ( VOLUME ) AS REVENUE FROM ( SELECT N1 . N_NAME AS SUPP_NATION , N2 . N_NAME AS CUST_NATION , EXTRACT ( YEAR FROM L_SHIPDATE ) AS L_YEAR , L_EXTENDEDPRICE * ( 1 - L_DISCOUNT ) AS VOLUME FROM SUPPLIER , LINEITEM , ORDERS , CUSTOMER , NATION N1 , NATION N2 WHERE S_SUPPKEY = L_SUPPKEY AND O_ORDERKEY = L_ORDERKEY AND C_CUSTKEY = O_CUSTKEY AND S_NATIONKEY = N1 . N_NATIONKEY AND C_NATIONKEY = N2 . N_NATIONKEY AND ( ( N1 . N_NAME = 'JAPAN' AND N2 . N_NAME = 'INDIA' ) OR ( N1 . N_NAME = 'INDIA' AND N2 . N_NAME = 'JAPAN' ) ) AND L_SHIPDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31' ) AS SHIPPING GROUP BY SUPP_NATION , CUST_NATION , L_YEAR ORDER BY SUPP_NATION , CUST_NATION , L_YEAR ; ...","title":"What-if Validation"},{"location":"pawindexadvisor/what-if-validation/#what-if-validation","text":"The other result file is the %paw_index_what_if.txt which explains how recommended indexes helps the analyzed queries. This result file is generated only when the What-if analysis validation option is enabled. This file contains a list of query's validation information. For each query, it reveals following information.","title":"What-if Validation"},{"location":"pawindexadvisor/what-if-validation/#query-id","text":"The identification of the input query. It is a combinnation of input SQL file name and a \" stmt \" + ordinal of the SQL statement in the input SQL file. So the \" 17.sql-stmt1 \" means the first SQL statement in 17.sql file. - 17.sql-stmt1 -- query id","title":"Query ID"},{"location":"pawindexadvisor/what-if-validation/#query-text","text":"The original query text which is analyzed and optimized to improve its performance. SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY );","title":"Query Text"},{"location":"pawindexadvisor/what-if-validation/#performance-improvement","text":"The performance improvement(pi) of the query named query id . The performance improvement is calculate according to the cost before and after recommended indexes virtually applied[^2]. - performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] The calculation formula for pi is pi = (cost_before - cost_after) / cost_after","title":"Performance Improvement"},{"location":"pawindexadvisor/what-if-validation/#cost-before","text":"The query cost before the recommended indexes are applied.","title":"Cost Before"},{"location":"pawindexadvisor/what-if-validation/#cost-after","text":"The query cost after the recommended indexes are applied.","title":"Cost After"},{"location":"pawindexadvisor/what-if-validation/#contributing-indexes","text":"The indexes contribute to the query execution, including the existing indexes and recommended indexes. - Contributing indice:[PAW_IDX1352615704, PAW_IDX0607681583, PAW_IDX1285498835] -- the indexes used","title":"Contributing Indexes"},{"location":"pawindexadvisor/what-if-validation/#paw_index_what-iftxt","text":"/****************************************************************\\ * * * Recommended Index Validation Details * * * * Powered by PawSQL(2022 - ) * * * \\****************************************************************/ -- Recommended indexes CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); ... -- Validation details -- 17.sql1, performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] Contributing indice :[ PAW_IDX1352615704 , PAW_IDX0607681583 , PAW_IDX1285498835 ] SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY ); -- 21.sql1, performance improves by 1173.2289478709183%[cost_before=1333.58,after_cost=104.74] Contributing indice :[ PAW_IDX1621082330 , PAW_IDX1003493942 , PAW_IDX1416165687 , IDX_LINEITEM_ORDERKEY , PAW_IDX0538538531 ] SELECT S_NAME , COUNT ( * ) AS NUMWAIT FROM SUPPLIER , LINEITEM L1 , ORDERS , NATION WHERE S_SUPPKEY = L1 . L_SUPPKEY AND O_ORDERKEY = L1 . L_ORDERKEY AND O_ORDERSTATUS = 'F' AND L1 . L_RECEIPTDATE > L1 . L_COMMITDATE AND EXISTS ( SELECT * FROM LINEITEM L2 WHERE L2 . L_ORDERKEY = L1 . L_ORDERKEY AND L2 . L_SUPPKEY <> L1 . L_SUPPKEY ) AND NOT EXISTS ( SELECT * FROM LINEITEM L3 WHERE L3 . L_ORDERKEY = L1 . L_ORDERKEY AND L3 . L_SUPPKEY <> L1 . L_SUPPKEY AND L3 . L_RECEIPTDATE > L3 . L_COMMITDATE ) AND S_NATIONKEY = N_NATIONKEY AND N_NAME = 'EGYPT' GROUP BY S_NAME ORDER BY NUMWAIT DESC , S_NAME LIMIT 100 ; -- 7.sql1, performance improves by 3877.8084714548804%[cost_before=863.98,after_cost=21.72] Contributing indice :[ PAW_IDX1264424863 , PAW_IDX1409884827 , PAW_IDX1017563074 , CUSTOMER_PKEY , PAW_IDX1640274034 , PAW_IDX1640274034 ] SELECT SUPP_NATION , CUST_NATION , L_YEAR , SUM ( VOLUME ) AS REVENUE FROM ( SELECT N1 . N_NAME AS SUPP_NATION , N2 . N_NAME AS CUST_NATION , EXTRACT ( YEAR FROM L_SHIPDATE ) AS L_YEAR , L_EXTENDEDPRICE * ( 1 - L_DISCOUNT ) AS VOLUME FROM SUPPLIER , LINEITEM , ORDERS , CUSTOMER , NATION N1 , NATION N2 WHERE S_SUPPKEY = L_SUPPKEY AND O_ORDERKEY = L_ORDERKEY AND C_CUSTKEY = O_CUSTKEY AND S_NATIONKEY = N1 . N_NATIONKEY AND C_NATIONKEY = N2 . N_NATIONKEY AND ( ( N1 . N_NAME = 'JAPAN' AND N2 . N_NAME = 'INDIA' ) OR ( N1 . N_NAME = 'INDIA' AND N2 . N_NAME = 'JAPAN' ) ) AND L_SHIPDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31' ) AS SHIPPING GROUP BY SUPP_NATION , CUST_NATION , L_YEAR ORDER BY SUPP_NATION , CUST_NATION , L_YEAR ; ...","title":"paw_index_what-if.txt"},{"location":"pawreference/","text":"","title":"Inside of PawSQL"},{"location":"pawreference/ActivationCodeforPlugin/","text":"Activation Code for Plug-in \u00b6 How to create an activation code for PawSQL plug-in \u00b6 If you don't have your own activation code for PawSQL plug-in , here are the steps to create an account and activation code. Step 1. Create a PawSQL account at PawSQL Cloud A PawSQL account for PawSQL Cloud and the plug-in will be created automatically after you sign up the PawSQL Cloud application. Step 2. Navigate to account setting page and copy activation code for your account Login PawSQL Cloud and navigate to account setting page, scroll down to the activation code section. Copy activation code for your account. Step 3. Open you IDE and paste your account and activation code to plug-in setting pages Step 4. Apply/Save settings. How to re-activate the activation code \u00b6 Step 1. Login PawSQL Cloud and navigate to account setting page, scroll down to the activation code section. Step 2. Click the re-activate button, you will get a new activation code. Step 3. Open you IDE and paste your account and activation code to plug-in setting pages Step 4 . Apply/Save settings.","title":"Activation Code for Plugin"},{"location":"pawreference/ActivationCodeforPlugin/#activation-code-for-plug-in","text":"","title":"Activation Code for Plug-in"},{"location":"pawreference/ActivationCodeforPlugin/#how-to-create-an-activation-code-for-pawsql-plug-in","text":"If you don't have your own activation code for PawSQL plug-in , here are the steps to create an account and activation code. Step 1. Create a PawSQL account at PawSQL Cloud A PawSQL account for PawSQL Cloud and the plug-in will be created automatically after you sign up the PawSQL Cloud application. Step 2. Navigate to account setting page and copy activation code for your account Login PawSQL Cloud and navigate to account setting page, scroll down to the activation code section. Copy activation code for your account. Step 3. Open you IDE and paste your account and activation code to plug-in setting pages Step 4. Apply/Save settings.","title":"How to create an activation code for PawSQL plug-in"},{"location":"pawreference/ActivationCodeforPlugin/#how-to-re-activate-the-activation-code","text":"Step 1. Login PawSQL Cloud and navigate to account setting page, scroll down to the activation code section. Step 2. Click the re-activate button, you will get a new activation code. Step 3. Open you IDE and paste your account and activation code to plug-in setting pages Step 4 . Apply/Save settings.","title":"How to re-activate the activation code"},{"location":"pawreference/JoinElimination/","text":"\u8fde\u63a5\u6d88\u9664\uff08Join Elimination\uff09 \u00b6 \u9ad8\u7ea7SQL\u4f18\u5316\u7cfb\u5217\uff08Channel of advanced SQL tuning\uff09 \u5b9a\u4e49 \u00b6 \u8fde\u63a5\u6d88\u9664\uff08Join Elimination\uff09\u901a\u8fc7\u5728\u4e0d\u5f71\u54cd\u6700\u7ec8\u7ed3\u679c\u7684\u60c5\u51b5\u4e0b\u4ece\u67e5\u8be2\u4e2d\u5220\u9664\u8868\uff0c\u6765\u7b80\u5316SQL\u4ee5\u63d0\u9ad8\u67e5\u8be2\u6027\u80fd\u3002\u901a\u5e38\uff0c\u5f53\u67e5\u8be2\u5305\u542b\u4e3b\u952e-\u5916\u952e\u8fde\u63a5\u5e76\u4e14\u67e5\u8be2\u4e2d\u4ec5\u5f15\u7528\u4e3b\u8868\u7684\u4e3b\u952e\u5217\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528\u6b64\u4f18\u5316\u3002 \u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff0c select o . * from orders o inner join customer c on c . c_custkey = o . o_custkey \u8ba2\u5355\u8868\uff08orders\uff09\u548c\u5ba2\u6237\u8868\uff08customer\uff09\u5173\u8054\uff0c\u4e14c_custkey\u662f\u5ba2\u6237\u8868\u7684\u4e3b\u952e\uff0c\u90a3\u4e48\u5ba2\u6237\u8868\u53ef\u4ee5\u88ab\u6d88\u9664\u6389\uff0c\u91cd\u5199\u540e\u7684SQL\u5982\u4e0b\uff1a select * from orders where o_custkey is not null \u8fde\u63a5\u6d88\u9664\u7684\u7c7b\u578b \u00b6 \u5185\u8fde\u63a5\u6d88\u9664 \u00b6 \u5185\u8fde\u63a5\u6d88\u9664\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \u4e8b\u5b9e\u4e0a\u7684\u4e3b\u5916\u952e\u7b49\u503c\u8fde\u63a5\uff08\u7236\u8868\u7684\u8fde\u63a5\u5217\u975e\u7a7a\u4e14\u552f\u4e00\uff09 \u7236\u8868\u7684\u4e3b\u952e\u662f\u67e5\u8be2\u4e2d\u552f\u4e00\u88ab\u5f15\u7528\u7684\u7236\u8868\u7684\u5217 \u5185\u8fde\u63a5\u6d88\u9664\u7684\u65b9\u5f0f\uff1a \u7236\u8868\u53ca\u4e3b\u5916\u952e\u8fde\u63a5\u6761\u4ef6\u88ab\u6d88\u9664 \u5176\u4ed6\u5bf9\u4e8e\u7236\u8868\u4e3b\u952e\u7684\u5f15\u7528\u88ab\u66ff\u6362\u6210\u5916\u8868\u7684\u5916\u952e \u5982\u679c\u5916\u952e\u53ef\u4ee5\u4e3a\u7a7a\u4e14\u65e0\u5176\u4ed6\u7684NFC\u6761\u4ef6 1 \uff0c\u5219\u9700\u8981\u65b0\u589e\u4e00\u4e2a\u5916\u952e\u4e0d\u4e3a\u7a7a\u7684\u6761\u4ef6 \u6848\u4f8b\uff1a - \u539f\u59cbSQL select c_custkey from customer , orders where c_custkey = o_custkey \u91cd\u5199\u540e\u7684SQL select orders . o_custkey from orders where orders . o_custkey is not null \u5916\u8fde\u63a5\u6d88\u9664 \u00b6 \u5916\u8fde\u63a5\u6d88\u9664\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\uff1a \u88ab\u6d88\u9664\u7684\u5916\u8fde\u63a5\u5fc5\u987b\u662f\u4e00\u4e2a\u5de6\u5916\u8fde\u63a5\u6216\u53f3\u5916\u8fde\u63a5 \u8fde\u63a5\u7684\u6761\u4ef6\u5fc5\u987b\u5b58\u5728\u4e00\u4e2a\u7531 AND \u8fde\u63a5\u7684\u4e3b\u5916\u952e\u7b49\u503c\u8fde\u63a5 \u5185\u8868\u7684\u4e3b\u952e\uff08\u975e\u7a7a\u4e14\u552f\u4e00\uff09\u662f\u67e5\u8be2\u4e2d\u552f\u4e00\u88ab\u5f15\u7528\u7684\u5185\u8868\u7684\u5217 \u5916\u8fde\u63a5\u6d88\u9664\u7684\u65b9\u5f0f\uff1a \u5185\u8868\u53ca\u5176\u5168\u90e8\u8fde\u63a5\u6761\u4ef6\u88ab\u6d88\u9664 \u5176\u4ed6\u5bf9\u4e8e\u5185\u8868\u4e3b\u952e\u7684\u5f15\u7528\u88ab\u66ff\u6362\u6210\u5185\u8868\u7684\u5916\u952e \u6848\u4f8b1\uff1aPK\u53ea\u51fa\u73b0\u5728\u8fde\u63a5\u6761\u4ef6\u4e2d \u539f\u59cbSQL select o_custkey from orders left join customer on c_custkey = o_custkey \u91cd\u5199\u540e\u7684SQL select orders . o_custkey from orders \u6848\u4f8b2\uff1aPK\u51fa\u73b0\u5728\u5176\u4ed6\u5730\u65b9 \u539f\u59cbSQL select orders . * from customer right join orders on c_custkey = o_custkey and c_custkey > 20 where o_orderstatus = 'T' \u91cd\u5199\u540e\u7684SQL select orders . * from orders where orders . o_orderstatus = 'T' \u6570\u636e\u5e93\u4e2d\u7684\u8fde\u63a5\u6d88\u9664 \u00b6 \u5bf9\u4e8e\u7b2c\u4e00\u7ae0\u8282\u4e2d\u7684SQL: select o.* from orders o inner join customer c on c.c_custkey=o.o_custkey MySQL\u6267\u884c\u8ba1\u5212\u4e3a\uff1a -> Inner hash join ( o . O_CUSTKEY = c . C_CUSTKEY ) ( cost = 20541 . 07 rows = 20013 ) -> Table scan on o ( cost = 2529 . 20 rows = 200128 ) -> Hash -> Index scan on c using key_idx ( cost = 0 . 35 rows = 1 ) PostgreSQL\u7684\u6267\u884c\u8ba1\u5212\u4e3a\uff1a Hash Join ( cost = 401 . 29 .. 711 . 56 rows = 10001 width = 115 ) Hash Cond : ( o . o_custkey = c . c_custkey ) -> Seq Scan on orders o ( cost = 0 . 00 .. 284 . 01 rows = 10001 width = 115 ) -> Hash ( cost = 276 . 29 .. 276 . 29 rows = 10000 width = 4 ) -> Index Only Scan using customer_pkey on customer c ( cost = 0 . 29 .. 276 . 29 rows = 10000 width = 4 ) \u91cd\u8981\u63d0\u793a: \u53ef\u4ee5\u770b\u51fa\uff0cMySQL\u548cPostgreSQL\u90fd\u4e0d\u652f\u6301\u8fde\u63a5\u6d88\u9664\u91cd\u5199\u4f18\u5316\u3002 PawSQL\u4e2d\u7684\u8fde\u63a5\u6d88\u9664 \u00b6 PawSQL\u901a\u8fc7JoinEliminationRewrite\u4f18\u5316\u91cd\u5199\uff0c\u63d0\u4f9b\u6bd4\u8f83\u5b8c\u5584\u7684\u8fde\u63a5\u6d88\u9664\u4f18\u5316\u3002 \u8f93\u5165SQL\u8bed\u53e5 select orders . * from customer right join orders on c_custkey = o_custkey and c_custkey > 20 \u5e94\u7528JoinEliminationRewrite\u540e\u91cd\u5199\u7684SQL\u4e3a\uff1a select orders . * from orders \u4f18\u5316\u524d\u7684\u6267\u884c\u8ba1\u5212 -> Nested loop left join ( cost = 90585 . 51 rows = 200128 ) -> Table scan on orders ( cost = 20540 . 71 rows = 200128 ) -> Filter : ( orders . O_CUSTKEY > 20 ) ( cost = 0 . 25 rows = 1 ) -> Single - row covering index lookup on customer using key_idx ( C_CUSTKEY = orders . O_CUSTKEY ) ( cost = 0 . 25 rows = 1 ) \u4f18\u5316\u540e\u7684\u6267\u884c -> Table scan on orders ( cost = 20540 . 71 rows = 200128 ) \u53ef\u4ee5\u770b\u5230\uff0cPawSQL\u5f88\u597d\u7684\u652f\u6301\u4e86\u8fde\u63a5\u6d88\u9664\u91cd\u5199\u4f18\u5316\uff0c\u4ec5\u4ec5\u901a\u8fc7\u8fde\u63a5\u6d88\u9664\u91cd\u5199\uff0c\u6027\u80fd\u7684\u63d0\u5347\u5c31\u8fbe\u5230\u4e86441.01%. \u8054\u7cfb\u6211\u4eec \u00b6 \u90ae\u4ef6\uff1a service@pawsql.com Twitter: https://twitter.com/pawsql \u626b\u63cf\u5173\u6ce8PawSQL\u516c\u4f17\u53f7 \u5173\u4e8eNFC\u6761\u4ef6\uff0c\u8bf7\u53c2\u8003\u9ad8\u7ea7SQL\u4f18\u5316\u7cfb\u5217\u4e2d \u5916\u8fde\u63a5\u4f18\u5316 \u4e2d\u5bf9\u4e8eNFC\u7684\u5b9a\u4e49 \u21a9","title":"Join Elimination"},{"location":"pawreference/JoinElimination/#join-elimination","text":"\u9ad8\u7ea7SQL\u4f18\u5316\u7cfb\u5217\uff08Channel of advanced SQL tuning\uff09","title":"\u8fde\u63a5\u6d88\u9664\uff08Join Elimination\uff09"},{"location":"pawreference/JoinElimination/#_1","text":"\u8fde\u63a5\u6d88\u9664\uff08Join Elimination\uff09\u901a\u8fc7\u5728\u4e0d\u5f71\u54cd\u6700\u7ec8\u7ed3\u679c\u7684\u60c5\u51b5\u4e0b\u4ece\u67e5\u8be2\u4e2d\u5220\u9664\u8868\uff0c\u6765\u7b80\u5316SQL\u4ee5\u63d0\u9ad8\u67e5\u8be2\u6027\u80fd\u3002\u901a\u5e38\uff0c\u5f53\u67e5\u8be2\u5305\u542b\u4e3b\u952e-\u5916\u952e\u8fde\u63a5\u5e76\u4e14\u67e5\u8be2\u4e2d\u4ec5\u5f15\u7528\u4e3b\u8868\u7684\u4e3b\u952e\u5217\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528\u6b64\u4f18\u5316\u3002 \u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff0c select o . * from orders o inner join customer c on c . c_custkey = o . o_custkey \u8ba2\u5355\u8868\uff08orders\uff09\u548c\u5ba2\u6237\u8868\uff08customer\uff09\u5173\u8054\uff0c\u4e14c_custkey\u662f\u5ba2\u6237\u8868\u7684\u4e3b\u952e\uff0c\u90a3\u4e48\u5ba2\u6237\u8868\u53ef\u4ee5\u88ab\u6d88\u9664\u6389\uff0c\u91cd\u5199\u540e\u7684SQL\u5982\u4e0b\uff1a select * from orders where o_custkey is not null","title":"\u5b9a\u4e49"},{"location":"pawreference/JoinElimination/#_2","text":"","title":"\u8fde\u63a5\u6d88\u9664\u7684\u7c7b\u578b"},{"location":"pawreference/JoinElimination/#_3","text":"\u5185\u8fde\u63a5\u6d88\u9664\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \u4e8b\u5b9e\u4e0a\u7684\u4e3b\u5916\u952e\u7b49\u503c\u8fde\u63a5\uff08\u7236\u8868\u7684\u8fde\u63a5\u5217\u975e\u7a7a\u4e14\u552f\u4e00\uff09 \u7236\u8868\u7684\u4e3b\u952e\u662f\u67e5\u8be2\u4e2d\u552f\u4e00\u88ab\u5f15\u7528\u7684\u7236\u8868\u7684\u5217 \u5185\u8fde\u63a5\u6d88\u9664\u7684\u65b9\u5f0f\uff1a \u7236\u8868\u53ca\u4e3b\u5916\u952e\u8fde\u63a5\u6761\u4ef6\u88ab\u6d88\u9664 \u5176\u4ed6\u5bf9\u4e8e\u7236\u8868\u4e3b\u952e\u7684\u5f15\u7528\u88ab\u66ff\u6362\u6210\u5916\u8868\u7684\u5916\u952e \u5982\u679c\u5916\u952e\u53ef\u4ee5\u4e3a\u7a7a\u4e14\u65e0\u5176\u4ed6\u7684NFC\u6761\u4ef6 1 \uff0c\u5219\u9700\u8981\u65b0\u589e\u4e00\u4e2a\u5916\u952e\u4e0d\u4e3a\u7a7a\u7684\u6761\u4ef6 \u6848\u4f8b\uff1a - \u539f\u59cbSQL select c_custkey from customer , orders where c_custkey = o_custkey \u91cd\u5199\u540e\u7684SQL select orders . o_custkey from orders where orders . o_custkey is not null","title":"\u5185\u8fde\u63a5\u6d88\u9664"},{"location":"pawreference/JoinElimination/#_4","text":"\u5916\u8fde\u63a5\u6d88\u9664\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\uff1a \u88ab\u6d88\u9664\u7684\u5916\u8fde\u63a5\u5fc5\u987b\u662f\u4e00\u4e2a\u5de6\u5916\u8fde\u63a5\u6216\u53f3\u5916\u8fde\u63a5 \u8fde\u63a5\u7684\u6761\u4ef6\u5fc5\u987b\u5b58\u5728\u4e00\u4e2a\u7531 AND \u8fde\u63a5\u7684\u4e3b\u5916\u952e\u7b49\u503c\u8fde\u63a5 \u5185\u8868\u7684\u4e3b\u952e\uff08\u975e\u7a7a\u4e14\u552f\u4e00\uff09\u662f\u67e5\u8be2\u4e2d\u552f\u4e00\u88ab\u5f15\u7528\u7684\u5185\u8868\u7684\u5217 \u5916\u8fde\u63a5\u6d88\u9664\u7684\u65b9\u5f0f\uff1a \u5185\u8868\u53ca\u5176\u5168\u90e8\u8fde\u63a5\u6761\u4ef6\u88ab\u6d88\u9664 \u5176\u4ed6\u5bf9\u4e8e\u5185\u8868\u4e3b\u952e\u7684\u5f15\u7528\u88ab\u66ff\u6362\u6210\u5185\u8868\u7684\u5916\u952e \u6848\u4f8b1\uff1aPK\u53ea\u51fa\u73b0\u5728\u8fde\u63a5\u6761\u4ef6\u4e2d \u539f\u59cbSQL select o_custkey from orders left join customer on c_custkey = o_custkey \u91cd\u5199\u540e\u7684SQL select orders . o_custkey from orders \u6848\u4f8b2\uff1aPK\u51fa\u73b0\u5728\u5176\u4ed6\u5730\u65b9 \u539f\u59cbSQL select orders . * from customer right join orders on c_custkey = o_custkey and c_custkey > 20 where o_orderstatus = 'T' \u91cd\u5199\u540e\u7684SQL select orders . * from orders where orders . o_orderstatus = 'T'","title":"\u5916\u8fde\u63a5\u6d88\u9664"},{"location":"pawreference/JoinElimination/#_5","text":"\u5bf9\u4e8e\u7b2c\u4e00\u7ae0\u8282\u4e2d\u7684SQL: select o.* from orders o inner join customer c on c.c_custkey=o.o_custkey MySQL\u6267\u884c\u8ba1\u5212\u4e3a\uff1a -> Inner hash join ( o . O_CUSTKEY = c . C_CUSTKEY ) ( cost = 20541 . 07 rows = 20013 ) -> Table scan on o ( cost = 2529 . 20 rows = 200128 ) -> Hash -> Index scan on c using key_idx ( cost = 0 . 35 rows = 1 ) PostgreSQL\u7684\u6267\u884c\u8ba1\u5212\u4e3a\uff1a Hash Join ( cost = 401 . 29 .. 711 . 56 rows = 10001 width = 115 ) Hash Cond : ( o . o_custkey = c . c_custkey ) -> Seq Scan on orders o ( cost = 0 . 00 .. 284 . 01 rows = 10001 width = 115 ) -> Hash ( cost = 276 . 29 .. 276 . 29 rows = 10000 width = 4 ) -> Index Only Scan using customer_pkey on customer c ( cost = 0 . 29 .. 276 . 29 rows = 10000 width = 4 ) \u91cd\u8981\u63d0\u793a: \u53ef\u4ee5\u770b\u51fa\uff0cMySQL\u548cPostgreSQL\u90fd\u4e0d\u652f\u6301\u8fde\u63a5\u6d88\u9664\u91cd\u5199\u4f18\u5316\u3002","title":"\u6570\u636e\u5e93\u4e2d\u7684\u8fde\u63a5\u6d88\u9664"},{"location":"pawreference/JoinElimination/#pawsql","text":"PawSQL\u901a\u8fc7JoinEliminationRewrite\u4f18\u5316\u91cd\u5199\uff0c\u63d0\u4f9b\u6bd4\u8f83\u5b8c\u5584\u7684\u8fde\u63a5\u6d88\u9664\u4f18\u5316\u3002 \u8f93\u5165SQL\u8bed\u53e5 select orders . * from customer right join orders on c_custkey = o_custkey and c_custkey > 20 \u5e94\u7528JoinEliminationRewrite\u540e\u91cd\u5199\u7684SQL\u4e3a\uff1a select orders . * from orders \u4f18\u5316\u524d\u7684\u6267\u884c\u8ba1\u5212 -> Nested loop left join ( cost = 90585 . 51 rows = 200128 ) -> Table scan on orders ( cost = 20540 . 71 rows = 200128 ) -> Filter : ( orders . O_CUSTKEY > 20 ) ( cost = 0 . 25 rows = 1 ) -> Single - row covering index lookup on customer using key_idx ( C_CUSTKEY = orders . O_CUSTKEY ) ( cost = 0 . 25 rows = 1 ) \u4f18\u5316\u540e\u7684\u6267\u884c -> Table scan on orders ( cost = 20540 . 71 rows = 200128 ) \u53ef\u4ee5\u770b\u5230\uff0cPawSQL\u5f88\u597d\u7684\u652f\u6301\u4e86\u8fde\u63a5\u6d88\u9664\u91cd\u5199\u4f18\u5316\uff0c\u4ec5\u4ec5\u901a\u8fc7\u8fde\u63a5\u6d88\u9664\u91cd\u5199\uff0c\u6027\u80fd\u7684\u63d0\u5347\u5c31\u8fbe\u5230\u4e86441.01%.","title":"PawSQL\u4e2d\u7684\u8fde\u63a5\u6d88\u9664"},{"location":"pawreference/JoinElimination/#_6","text":"\u90ae\u4ef6\uff1a service@pawsql.com Twitter: https://twitter.com/pawsql \u626b\u63cf\u5173\u6ce8PawSQL\u516c\u4f17\u53f7 \u5173\u4e8eNFC\u6761\u4ef6\uff0c\u8bf7\u53c2\u8003\u9ad8\u7ea7SQL\u4f18\u5316\u7cfb\u5217\u4e2d \u5916\u8fde\u63a5\u4f18\u5316 \u4e2d\u5bf9\u4e8eNFC\u7684\u5b9a\u4e49 \u21a9","title":"\u8054\u7cfb\u6211\u4eec"},{"location":"pawreference/Outer2Inner/","text":"\u5916\u8fde\u63a5\u8f6c\u5316\u4e3a\u5185\u8fde\u63a5 \u00b6 \u9ad8\u7ea7SQL\u4f18\u5316\u7cfb\u5217\uff08Channel of advanced SQL tuning\uff09 \u8868\u8fde\u63a5\u7684\u7c7b\u578b \u00b6 \u8868\u8fde\u63a5\u7684\u7c7b\u578b\u4e3b\u8981\u5206\u4e3a\u5185\u8fde\u63a5\u3001\u5916\u8fde\u63a5\uff08\u5de6\u5916\u3001\u53f3\u5916\u3001\u5168\u5916\uff09\u3001\u4ea4\u53c9\u8fde\u63a5\uff0c\u5173\u4e8e\u4ed6\u4eec\u7684\u8bed\u4e49\u53ef\u4ee5\u53c2\u8003\u4e0b\u56fe\u3002 \u6b64\u56fe\u6765\u81ea \u6587\u7ae0(Visual Representation of SQL Joins) \uff0c\u63cf\u8ff0\u7684\u975e\u5e38\u6e05\u695a\uff0c\u672c\u6587\u4e0d\u505a\u592a\u591a\u8d58\u8ff0\u3002 \u8fde\u63a5\u7c7b\u578b\u5bf9\u6267\u884c\u8ba1\u5212\u7684\u5f71\u54cd \u00b6 \u6211\u4eec\u77e5\u9053\u6570\u636e\u5e93\u4f18\u5316\u5668\u91c7\u7528\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u5bf9\u53ef\u80fd\u7684\u6267\u884c\u8def\u5f84\u8fdb\u884c\u4ee3\u4ef7\u4f30\u7b97\uff0c\u4ee5\u9009\u62e9\u51fa\u4ee3\u4ef7\u5c3d\u91cf\u5c0f\u7684\u6267\u884c\u8ba1\u5212\u8fdb\u884c\u6267\u884c\u3002\u6570\u636e\u5e93\u4f18\u5316\u5668\u5bf9\u6267\u884c\u8def\u5f84\u8fdb\u884c\u89c4\u5212\u65f6\uff0c\u4e3b\u8981\u8fdb\u884c\u4e09\u7c7b\u89c4\u5212\uff1a\u6570\u636e\u8868\u7684\u8bbf\u95ee\u65b9\u5f0f\uff1b\u8868\u8fde\u63a5\u7684\u987a\u5e8f\uff1b\u8868\u8fde\u63a5\u7684\u65b9\u6cd5\u3002 \u5f53\u4f18\u5316\u5668\u8fdb\u884c\u8868\u8fde\u63a5\u7684\u89c4\u5212\u65f6\uff0c\u5bf9\u4e8eNested Loop Join\u8fde\u63a5\u65b9\u6cd5\uff0c\u5b83\u53ea\u8003\u8651\u4ee5\u4e0b\u8ba1\u5212\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\u64cd\u4f5c\uff0c\u5916\u90e8\u8868\u90fd\u4f1a\u5148\u4e8e\u5185\u90e8\u8868\u88ab\u8bbf\u95ee\u3002\u56e0\u6b64\u5f53\u4f7f\u7528\u5916\u8fde\u63a5\u65f6\uff0c\u5185\u5916\u8868\u5728SQL\u4e2d\u5c31\u88ab\u660e\u786e\u4e86\uff08\u5916\u8868\u4e3a\u5de6\u8fde\u63a5\u7684\u5de6\u8868/\u53f3\u8fde\u63a5\u7684\u53f3\u8868\uff09\uff0c\u4f18\u5316\u5668\u7684\u9009\u62e9\u662f\u6709\u9650\u7684,\u56e0\u800c\u53ef\u80fd\u5bfc\u81f4\u6027\u80fd\u8f83\u4f4e\u7684\u6267\u884c\u8ba1\u5212\u3002 \u4ee5MySQL\u5b98\u65b9\u6587\u6863\u4e0a\u7684 \u4f8b\u5b50 \u6765\u8bf4\u660e\uff1a \u8003\u8651\u4e0b\u9762\u8fd9\u79cd\u5f62\u5f0f\u7684\u67e5\u8be2\uff0c\u5176\u4e2d R(T2) \u6781\u5927\u5730\u8fc7\u6ee4\u4e86\u6765\u81ea T2 \u8868\u7684\u5339\u914d\u884c\u6570: SELECT * T1 FROM T1 LEFT JOIN T2 ON P1(T1,T2) WHERE P(T1,T2) AND R(T2) \u5982\u679c\u6309\u7167\u4e0a\u9762\u6240\u8ff0\u7684\u6267\u884c\u67e5\u8be2\uff0c\u4f18\u5316\u5668\u6ca1\u6709\u9009\u62e9\u4f59\u5730\uff0c\u53ea\u80fd\u5148\u8bbf\u95ee\u9650\u5236\u8f83\u5c11\u7684 T1 \u8868\uff0c\u7136\u540e\u518d\u8bbf\u95ee\u9650\u5236\u8f83\u591a\u7684 T2 \u8868\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u975e\u5e38\u4f4e\u6548\u7684\u6267\u884c\u8ba1\u5212\u3002 \u5bf9\u4e8e\u5168\u5916\u8fde\u63a5\uff0c\u4f18\u5316\u5668\u4e00\u822c\u662f\u5c06\u5176\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5de6\u5916\u8054\u673a\u548c\u53f3\u5916\u8fde\u63a5\u7684UNION\u6216\u662f\u91c7\u7528FULL OUTER HASH JOIN\u8fdb\u884c\u6267\u884c\uff0c\u4f1a\u4ea7\u751f\u7c7b\u4f3c\u7684\u6027\u80fd\u95ee\u9898\u3002 \u5916\u8fde\u63a5\u7b80\u5316\u91cd\u5199 \u00b6 \u5982\u679cR(T2) \u662f\u4e00\u4e2a\u7a7a\u62d2\u7edd\u6761\u4ef6\u6761\u4ef6(NFC)\uff0c\u90a3\u4e48\u4ee5\u4e0a\u7684\u5916\u8fde\u63a5\u53ef\u4ee5\u8f6c\u5316\u4e3a\u5185\u8fde\u63a5\uff0c\u5373 SELECT * T1 FROM T1 JOIN T2 ON P1(T1,T2) WHERE P(T1,T2) AND R(T2) \u8fd9\u6837\uff0c\u4f18\u5316\u5668\u53ef\u4ee5\u5148\u5e94\u7528R(T2) \uff0c\u83b7\u53d6\u975e\u5e38\u5c0f\u7684\u7ed3\u679c\u96c6\uff0c\u7136\u540e\u518d\u548cT1\u8fdb\u884c\u5173\u8054\u3002 NFC\u6761\u4ef6\uff08NULL Filtered Condition\uff09 \u00b6 \u7a7a\u62d2\u7edd\u6761\u4ef6\u6307\u7684\u662f\uff0c\u5982\u679c\u8f93\u5165\u4e3aNULL\uff0c\u5219\u5176\u5224\u65ad\u7ed3\u679c\u4e3afalse\u6216\u662funknown\uff0c\u5bfc\u81f4\u8be5\u884c\u88ab\u8fc7\u6ee4\u6389\u7684\u6761\u4ef6\u3002\u5224\u65ad\u67d0\u4e2a\u6761\u4ef6\u662f\u5426\u4e3a\u5916\u8fde\u63a5\u64cd\u4f5c\u7684\u7a7a\u62d2\u7edd\u6761\u4ef6\uff08NFC\uff09\u7684\u89c4\u5219\u5f88\u7b80\u5355: \u5b83\u662f A IS NOT NULL \u7684\u5f62\u5f0f\uff0c\u5176\u4e2d A \u662f\u5185\u8868\u7684\u4efb\u4f55\u5c5e\u6027 \u5b83\u662f\u5305\u542b\u5185\u8868\u5f15\u7528\u7684\u8c13\u8bcd\uff0c\u5f53\u5176\u4e2d\u4e00\u4e2a\u53c2\u6570\u4e3a NULL \u65f6\u8bc4\u4f30\u4e3a UNKNOWN \u5b83\u662f\u5305\u542b\u7a7a\u62d2\u7edd\u6761\u4ef6\u7684\u201c\u4e0e\u5173\u8054\u201d\uff08AND\uff09\u7ec4\u5408 \u5b83\u662f\u7a7a\u62d2\u7edd\u6761\u4ef6\u7684\u201c\u6216\u5173\u8054\u201d\uff08OR\uff09\u7ec4\u5408 \u56e0\u6b64\uff0c\u5bf9\u4e8e\u8fd9\u4e2a\u5916\u8fde\u63a5: T1 LEFT JOIN T2 ON T1.A=T2.A \u4ee5\u4e0b\u7684\u6761\u4ef6\u88ab\u89c6\u4e3a\u7a7a\u62d2\u7edd\u6761\u4ef6\uff1a T2.B IS NOT NULL T2.B > 3 T2.C <= T1.C T1.B < 3 AND T2.B IS NOT NULL T2.B < 2 OR T2.C > 1 \u4ee5\u4e0b\u7684\u6761\u4ef6\u4e0d\u88ab\u89c6\u4e3a\u7a7a\u62d2\u7edd\u6761\u4ef6: T2.B IS NULL T1.B < 3 OR T2.B IS NOT NULL T1.B < 3 OR T2.B > 3 T2.B in (1,2, NULL) \u6570\u636e\u5e93\u4e2d\u7684\u5916\u8fde\u63a5\u7b80\u5316 \u00b6 \u7edd\u5927\u591a\u6570\u7684\u5173\u7cfb\u578b\u6570\u636e\u5e93\u4f18\u5316\u5668\u90fd\u80fd\u591f\u63d0\u4f9b\u4e0a\u8ff0\u7684\u5916\u8fde\u63a5\u7b80\u5316\u91cd\u5199\u3002\u4e0b\u9762\u4ee5\u4e00\u4e2a\u6848\u4f8b\u6765\u793a\u4f8b\u5728MySQL\u548cPostgreSQL\u4e2d\u7684\u5916\u8fde\u63a5\u7b80\u5316\u91cd\u5199\u3002 \u793a\u4f8bSQL\u8bed\u53e5 select c_custkey from orders left join customer on c_custkey=o_custkey where C_NATIONKEY < 20 MySQL\u6267\u884c\u8ba1\u5212 -> Inner hash join (orders.O_CUSTKEY = customer.C_CUSTKEY) (cost=20541.08 rows=20013) -> Table scan on orders (cost=2529.21 rows=200128) -> Hash -> Filter: (customer.C_NATIONKEY < 20) (cost=0.35 rows=1) -> Table scan on customer (cost=0.35 rows=1) PostgreSQL Hash Join (cost=100.19..410.47 rows=33 width=4) Hash Cond: (orders.o_custkey = customer.c_custkey) -> Seq Scan on orders (cost=0.00..284.01 rows=10001 width=4) -> Hash (cost=99.78..99.78 rows=33 width=4) -> Bitmap Heap Scan on customer (cost=4.54..99.78 rows=33 width=4) Recheck Cond: (c_nationkey < 20) -> Bitmap Index Scan on c_nationkey_idx (cost=0.00..4.53 rows=33 width=0) Index Cond: (c_nationkey < 20) \u4ece\u6267\u884c\u8ba1\u5212\u6765\u770b\uff0cMySQL\u548cPostgreSQL\u90fd\u652f\u6301\u5916\u8fde\u63a5\u5230\u5185\u8fde\u63a5\u7684\u91cd\u5199\u4f18\u5316\u3002 PawSQL\u4e2d\u7684\u5916\u8fde\u63a5\u91cd\u5199\u4f18\u5316 \u00b6 PawSQL\u5b9e\u73b0\u901a\u8fc7Outer2InnerConversionRewrite\u89c4\u5219\u5b9e\u73b0\u4e86\u7c7b\u4f3c\u7684\u91cd\u5199\u4f18\u5316\uff0c\u5b83\u652f\u6301\u5de6\u5916\u8fde\u63a5\u3001\u53f3\u5916\u8fde\u63a5\u5230\u5185\u8fde\u63a5\u7684\u91cd\u5199\u4f18\u5316\uff0c\u4ee5\u53ca\u5168\u5916\u8fde\u63a5\u5230\u5de6\u5916\u8054\u673a\u3001\u53f3\u5916\u8fde\u63a5\u6216\u5185\u8fde\u63a5\u7684\u91cd\u5199\u4f18\u5316\u3002 \u91cd\u8981\u63d0\u793a: PawSQL\u5b9e\u73b0Outer2InnerConversionRewrite\u4f18\u5316\u7684\u76ee\u7684\u4e0d\u662f\u4e3a\u4e86\u91cd\u73b0\u6570\u636e\u5e93\u4f18\u5316\u5668\u7684\u91cd\u5199\u4f18\u5316\u903b\u8f91\u3002PawSQL\u5b9e\u73b0\u5b83\u662f\u56e0\u4e3a\u5b83\u53ef\u4ee5\u89e6\u53d1\u6570\u636e\u5e93\u4f18\u5316\u5668\u4e0d\u80fd\u5b9e\u73b0\u7684\u7d22\u5f15\u63a8\u8350\u529f\u80fd\u3002 \u8f93\u5165SQL\u8bed\u53e5 select c_custkey from orders left join customer on c_custkey=o_custkey where C_NATIONKEY < 20 \u5e94\u7528Outer2InnerConversionRewrite\u540e\u91cd\u5199\u7684SQL\u4e3a\uff1a select c_custkey from orders left join customer on c_custkey=o_custkey where C_NATIONKEY < 20 \u63a8\u8350\u7d22\u5f15 \u91cd\u5199\u540e\u7684SQL\u901a\u8fc7PawSQL\u7d22\u5f15\u63a8\u8350\u5f15\u64ce\u63a8\u8350\u51fa\u5982\u4e0b\u4e24\u4e2a\u7d22\u5f15\u3002 CREATE INDEX CONCURRENTLY PAW_IDX1028958902 ON PUBLIC.ORDERS(O_CUSTKEY); CREATE INDEX CONCURRENTLY PAW_IDX1196677611 ON PUBLIC.CUSTOMER(C_NATIONKEY,C_CUSTKEY); \u6267\u884c\u8ba1\u5212 \u628a\u63a8\u8350\u51fa\u7684\u7d22\u5f15\u7eb3\u5165\u4f18\u5316\u5668\u89c4\u5212\u8303\u56f4\u540e\u7684\u6267\u884c\u8ba1\u5212\u4e3a\uff1a PostgreSQL\u4e0a\u7684\u6267\u884c\u8ba1\u5212 Nested Loop (cost=0.57..85.53 rows=33 width=4) -> Index Only Scan using paw_idx1196677611 on customer (cost=0.29..8.86 rows=33 width=4) Index Cond: (c_nationkey < 20) -> Index Only Scan using paw_idx1028958902 on orders (cost=0.29..2.24 rows=8 width=4) Index Cond: (o_custkey = customer.c_custkey) MySQL\u4e0a\u7684\u6267\u884c\u8ba1\u5212 -> Nested loop inner join (cost=1.91 rows=6) -> Filter: (customer.C_NATIONKEY < 20) (cost=0.35 rows=1) -> Index scan on customer using PAW_IDX1360881332 (cost=0.35 rows=1) -> Covering index lookup on orders using PAW_IDX1028958902 (O_CUSTKEY=customer.C_CUSTKEY) (cost=1.56 rows=6) \u53ef\u4ee5\u770b\u5230\uff0c\u901a\u8fc7PawSQL\u7684\u6574\u4e2a\u4f18\u5316\u6d41\u7a0b\uff0c\u901a\u8fc7\u7d22\u5f15\u63a8\u8350\u5f15\u64ce\u63a8\u8350\u7684\u4e24\u4e2a\u7d22\u5f15\uff0c\u5728\u6570\u636e\u91cf\u8f83\u5c0f\u7684PostgreSQL\u6570\u636e\u5e93\u4e0a\uff0c\u67e5\u8be2\u7684\u4ee3\u4ef7\u4ece410.47\u51cf\u4f4e\u523085.53\uff0c\u6027\u80fd\u63d0\u5347\u4e86379.91%\u3002\u800c\u5728\u6570\u636e\u91cf\u8f83\u5927\u7684MySQL\u6570\u636e\u5e93\u670d\u52a1\u5668\u4e0a\uff0c\u67e5\u8be2\u4ee3\u4ef7\u4ece20541.08\u964d\u4f4e\u52301.91\uff0c\u6027\u80fd\u63d0\u5347\u4e86553161.15%\u3002 \u9898\u5916\u8bdd\uff1a\u6d4b\u8bd5\u8fd9\u4e2a\u529f\u80fd\u662f\uff0c\u53d1\u73b0\u4e00\u4e2a\u77e5\u8bc6\u70b9\uff0c\u5728MySQL\u4e2d\uff0c\u5982\u679c\u67d0\u4e2a\u5b57\u6bb5\u88ab\u5b9a\u4e49\u4e3a\u5916\u952e\uff0c\u9ed8\u8ba4\u4f1a\u6709\u5bf9\u5e94\u7684\u7d22\u5f15\u5efa\u7acb\u5728\u4e0a\u9762\uff1b\u800c\u5728PostgreSQL\u7cfb\u5217\u7684\u6570\u636e\u5e93\u4e2d\uff0c\u5c06\u67d0\u4e9b\u5b57\u6bb5\u8bbe\u7f6e\u5916\u952e\u5e76\u4e0d\u4f1a\u81ea\u52a8\u5728\u8fd9\u4e9b\u5b57\u6bb5\u4e0a\u5efa\u4e0a\u7d22\u5f15\u3002 \u8054\u7cfb\u6211\u4eec \u00b6 \u90ae\u4ef6\uff1a service@pawsql.com Twitter: https://twitter.com/pawsql \u626b\u63cf\u5173\u6ce8PawSQL\u516c\u4f17\u53f7","title":"Outer2Inner Conversion"},{"location":"pawreference/Outer2Inner/#_1","text":"\u9ad8\u7ea7SQL\u4f18\u5316\u7cfb\u5217\uff08Channel of advanced SQL tuning\uff09","title":"\u5916\u8fde\u63a5\u8f6c\u5316\u4e3a\u5185\u8fde\u63a5"},{"location":"pawreference/Outer2Inner/#_2","text":"\u8868\u8fde\u63a5\u7684\u7c7b\u578b\u4e3b\u8981\u5206\u4e3a\u5185\u8fde\u63a5\u3001\u5916\u8fde\u63a5\uff08\u5de6\u5916\u3001\u53f3\u5916\u3001\u5168\u5916\uff09\u3001\u4ea4\u53c9\u8fde\u63a5\uff0c\u5173\u4e8e\u4ed6\u4eec\u7684\u8bed\u4e49\u53ef\u4ee5\u53c2\u8003\u4e0b\u56fe\u3002 \u6b64\u56fe\u6765\u81ea \u6587\u7ae0(Visual Representation of SQL Joins) \uff0c\u63cf\u8ff0\u7684\u975e\u5e38\u6e05\u695a\uff0c\u672c\u6587\u4e0d\u505a\u592a\u591a\u8d58\u8ff0\u3002","title":"\u8868\u8fde\u63a5\u7684\u7c7b\u578b"},{"location":"pawreference/Outer2Inner/#_3","text":"\u6211\u4eec\u77e5\u9053\u6570\u636e\u5e93\u4f18\u5316\u5668\u91c7\u7528\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u5bf9\u53ef\u80fd\u7684\u6267\u884c\u8def\u5f84\u8fdb\u884c\u4ee3\u4ef7\u4f30\u7b97\uff0c\u4ee5\u9009\u62e9\u51fa\u4ee3\u4ef7\u5c3d\u91cf\u5c0f\u7684\u6267\u884c\u8ba1\u5212\u8fdb\u884c\u6267\u884c\u3002\u6570\u636e\u5e93\u4f18\u5316\u5668\u5bf9\u6267\u884c\u8def\u5f84\u8fdb\u884c\u89c4\u5212\u65f6\uff0c\u4e3b\u8981\u8fdb\u884c\u4e09\u7c7b\u89c4\u5212\uff1a\u6570\u636e\u8868\u7684\u8bbf\u95ee\u65b9\u5f0f\uff1b\u8868\u8fde\u63a5\u7684\u987a\u5e8f\uff1b\u8868\u8fde\u63a5\u7684\u65b9\u6cd5\u3002 \u5f53\u4f18\u5316\u5668\u8fdb\u884c\u8868\u8fde\u63a5\u7684\u89c4\u5212\u65f6\uff0c\u5bf9\u4e8eNested Loop Join\u8fde\u63a5\u65b9\u6cd5\uff0c\u5b83\u53ea\u8003\u8651\u4ee5\u4e0b\u8ba1\u5212\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\u64cd\u4f5c\uff0c\u5916\u90e8\u8868\u90fd\u4f1a\u5148\u4e8e\u5185\u90e8\u8868\u88ab\u8bbf\u95ee\u3002\u56e0\u6b64\u5f53\u4f7f\u7528\u5916\u8fde\u63a5\u65f6\uff0c\u5185\u5916\u8868\u5728SQL\u4e2d\u5c31\u88ab\u660e\u786e\u4e86\uff08\u5916\u8868\u4e3a\u5de6\u8fde\u63a5\u7684\u5de6\u8868/\u53f3\u8fde\u63a5\u7684\u53f3\u8868\uff09\uff0c\u4f18\u5316\u5668\u7684\u9009\u62e9\u662f\u6709\u9650\u7684,\u56e0\u800c\u53ef\u80fd\u5bfc\u81f4\u6027\u80fd\u8f83\u4f4e\u7684\u6267\u884c\u8ba1\u5212\u3002 \u4ee5MySQL\u5b98\u65b9\u6587\u6863\u4e0a\u7684 \u4f8b\u5b50 \u6765\u8bf4\u660e\uff1a \u8003\u8651\u4e0b\u9762\u8fd9\u79cd\u5f62\u5f0f\u7684\u67e5\u8be2\uff0c\u5176\u4e2d R(T2) \u6781\u5927\u5730\u8fc7\u6ee4\u4e86\u6765\u81ea T2 \u8868\u7684\u5339\u914d\u884c\u6570: SELECT * T1 FROM T1 LEFT JOIN T2 ON P1(T1,T2) WHERE P(T1,T2) AND R(T2) \u5982\u679c\u6309\u7167\u4e0a\u9762\u6240\u8ff0\u7684\u6267\u884c\u67e5\u8be2\uff0c\u4f18\u5316\u5668\u6ca1\u6709\u9009\u62e9\u4f59\u5730\uff0c\u53ea\u80fd\u5148\u8bbf\u95ee\u9650\u5236\u8f83\u5c11\u7684 T1 \u8868\uff0c\u7136\u540e\u518d\u8bbf\u95ee\u9650\u5236\u8f83\u591a\u7684 T2 \u8868\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u975e\u5e38\u4f4e\u6548\u7684\u6267\u884c\u8ba1\u5212\u3002 \u5bf9\u4e8e\u5168\u5916\u8fde\u63a5\uff0c\u4f18\u5316\u5668\u4e00\u822c\u662f\u5c06\u5176\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5de6\u5916\u8054\u673a\u548c\u53f3\u5916\u8fde\u63a5\u7684UNION\u6216\u662f\u91c7\u7528FULL OUTER HASH JOIN\u8fdb\u884c\u6267\u884c\uff0c\u4f1a\u4ea7\u751f\u7c7b\u4f3c\u7684\u6027\u80fd\u95ee\u9898\u3002","title":"\u8fde\u63a5\u7c7b\u578b\u5bf9\u6267\u884c\u8ba1\u5212\u7684\u5f71\u54cd"},{"location":"pawreference/Outer2Inner/#_4","text":"\u5982\u679cR(T2) \u662f\u4e00\u4e2a\u7a7a\u62d2\u7edd\u6761\u4ef6\u6761\u4ef6(NFC)\uff0c\u90a3\u4e48\u4ee5\u4e0a\u7684\u5916\u8fde\u63a5\u53ef\u4ee5\u8f6c\u5316\u4e3a\u5185\u8fde\u63a5\uff0c\u5373 SELECT * T1 FROM T1 JOIN T2 ON P1(T1,T2) WHERE P(T1,T2) AND R(T2) \u8fd9\u6837\uff0c\u4f18\u5316\u5668\u53ef\u4ee5\u5148\u5e94\u7528R(T2) \uff0c\u83b7\u53d6\u975e\u5e38\u5c0f\u7684\u7ed3\u679c\u96c6\uff0c\u7136\u540e\u518d\u548cT1\u8fdb\u884c\u5173\u8054\u3002","title":"\u5916\u8fde\u63a5\u7b80\u5316\u91cd\u5199"},{"location":"pawreference/Outer2Inner/#nfcnull-filtered-condition","text":"\u7a7a\u62d2\u7edd\u6761\u4ef6\u6307\u7684\u662f\uff0c\u5982\u679c\u8f93\u5165\u4e3aNULL\uff0c\u5219\u5176\u5224\u65ad\u7ed3\u679c\u4e3afalse\u6216\u662funknown\uff0c\u5bfc\u81f4\u8be5\u884c\u88ab\u8fc7\u6ee4\u6389\u7684\u6761\u4ef6\u3002\u5224\u65ad\u67d0\u4e2a\u6761\u4ef6\u662f\u5426\u4e3a\u5916\u8fde\u63a5\u64cd\u4f5c\u7684\u7a7a\u62d2\u7edd\u6761\u4ef6\uff08NFC\uff09\u7684\u89c4\u5219\u5f88\u7b80\u5355: \u5b83\u662f A IS NOT NULL \u7684\u5f62\u5f0f\uff0c\u5176\u4e2d A \u662f\u5185\u8868\u7684\u4efb\u4f55\u5c5e\u6027 \u5b83\u662f\u5305\u542b\u5185\u8868\u5f15\u7528\u7684\u8c13\u8bcd\uff0c\u5f53\u5176\u4e2d\u4e00\u4e2a\u53c2\u6570\u4e3a NULL \u65f6\u8bc4\u4f30\u4e3a UNKNOWN \u5b83\u662f\u5305\u542b\u7a7a\u62d2\u7edd\u6761\u4ef6\u7684\u201c\u4e0e\u5173\u8054\u201d\uff08AND\uff09\u7ec4\u5408 \u5b83\u662f\u7a7a\u62d2\u7edd\u6761\u4ef6\u7684\u201c\u6216\u5173\u8054\u201d\uff08OR\uff09\u7ec4\u5408 \u56e0\u6b64\uff0c\u5bf9\u4e8e\u8fd9\u4e2a\u5916\u8fde\u63a5: T1 LEFT JOIN T2 ON T1.A=T2.A \u4ee5\u4e0b\u7684\u6761\u4ef6\u88ab\u89c6\u4e3a\u7a7a\u62d2\u7edd\u6761\u4ef6\uff1a T2.B IS NOT NULL T2.B > 3 T2.C <= T1.C T1.B < 3 AND T2.B IS NOT NULL T2.B < 2 OR T2.C > 1 \u4ee5\u4e0b\u7684\u6761\u4ef6\u4e0d\u88ab\u89c6\u4e3a\u7a7a\u62d2\u7edd\u6761\u4ef6: T2.B IS NULL T1.B < 3 OR T2.B IS NOT NULL T1.B < 3 OR T2.B > 3 T2.B in (1,2, NULL)","title":"NFC\u6761\u4ef6\uff08NULL Filtered Condition\uff09"},{"location":"pawreference/Outer2Inner/#_5","text":"\u7edd\u5927\u591a\u6570\u7684\u5173\u7cfb\u578b\u6570\u636e\u5e93\u4f18\u5316\u5668\u90fd\u80fd\u591f\u63d0\u4f9b\u4e0a\u8ff0\u7684\u5916\u8fde\u63a5\u7b80\u5316\u91cd\u5199\u3002\u4e0b\u9762\u4ee5\u4e00\u4e2a\u6848\u4f8b\u6765\u793a\u4f8b\u5728MySQL\u548cPostgreSQL\u4e2d\u7684\u5916\u8fde\u63a5\u7b80\u5316\u91cd\u5199\u3002 \u793a\u4f8bSQL\u8bed\u53e5 select c_custkey from orders left join customer on c_custkey=o_custkey where C_NATIONKEY < 20 MySQL\u6267\u884c\u8ba1\u5212 -> Inner hash join (orders.O_CUSTKEY = customer.C_CUSTKEY) (cost=20541.08 rows=20013) -> Table scan on orders (cost=2529.21 rows=200128) -> Hash -> Filter: (customer.C_NATIONKEY < 20) (cost=0.35 rows=1) -> Table scan on customer (cost=0.35 rows=1) PostgreSQL Hash Join (cost=100.19..410.47 rows=33 width=4) Hash Cond: (orders.o_custkey = customer.c_custkey) -> Seq Scan on orders (cost=0.00..284.01 rows=10001 width=4) -> Hash (cost=99.78..99.78 rows=33 width=4) -> Bitmap Heap Scan on customer (cost=4.54..99.78 rows=33 width=4) Recheck Cond: (c_nationkey < 20) -> Bitmap Index Scan on c_nationkey_idx (cost=0.00..4.53 rows=33 width=0) Index Cond: (c_nationkey < 20) \u4ece\u6267\u884c\u8ba1\u5212\u6765\u770b\uff0cMySQL\u548cPostgreSQL\u90fd\u652f\u6301\u5916\u8fde\u63a5\u5230\u5185\u8fde\u63a5\u7684\u91cd\u5199\u4f18\u5316\u3002","title":"\u6570\u636e\u5e93\u4e2d\u7684\u5916\u8fde\u63a5\u7b80\u5316"},{"location":"pawreference/Outer2Inner/#pawsql","text":"PawSQL\u5b9e\u73b0\u901a\u8fc7Outer2InnerConversionRewrite\u89c4\u5219\u5b9e\u73b0\u4e86\u7c7b\u4f3c\u7684\u91cd\u5199\u4f18\u5316\uff0c\u5b83\u652f\u6301\u5de6\u5916\u8fde\u63a5\u3001\u53f3\u5916\u8fde\u63a5\u5230\u5185\u8fde\u63a5\u7684\u91cd\u5199\u4f18\u5316\uff0c\u4ee5\u53ca\u5168\u5916\u8fde\u63a5\u5230\u5de6\u5916\u8054\u673a\u3001\u53f3\u5916\u8fde\u63a5\u6216\u5185\u8fde\u63a5\u7684\u91cd\u5199\u4f18\u5316\u3002 \u91cd\u8981\u63d0\u793a: PawSQL\u5b9e\u73b0Outer2InnerConversionRewrite\u4f18\u5316\u7684\u76ee\u7684\u4e0d\u662f\u4e3a\u4e86\u91cd\u73b0\u6570\u636e\u5e93\u4f18\u5316\u5668\u7684\u91cd\u5199\u4f18\u5316\u903b\u8f91\u3002PawSQL\u5b9e\u73b0\u5b83\u662f\u56e0\u4e3a\u5b83\u53ef\u4ee5\u89e6\u53d1\u6570\u636e\u5e93\u4f18\u5316\u5668\u4e0d\u80fd\u5b9e\u73b0\u7684\u7d22\u5f15\u63a8\u8350\u529f\u80fd\u3002 \u8f93\u5165SQL\u8bed\u53e5 select c_custkey from orders left join customer on c_custkey=o_custkey where C_NATIONKEY < 20 \u5e94\u7528Outer2InnerConversionRewrite\u540e\u91cd\u5199\u7684SQL\u4e3a\uff1a select c_custkey from orders left join customer on c_custkey=o_custkey where C_NATIONKEY < 20 \u63a8\u8350\u7d22\u5f15 \u91cd\u5199\u540e\u7684SQL\u901a\u8fc7PawSQL\u7d22\u5f15\u63a8\u8350\u5f15\u64ce\u63a8\u8350\u51fa\u5982\u4e0b\u4e24\u4e2a\u7d22\u5f15\u3002 CREATE INDEX CONCURRENTLY PAW_IDX1028958902 ON PUBLIC.ORDERS(O_CUSTKEY); CREATE INDEX CONCURRENTLY PAW_IDX1196677611 ON PUBLIC.CUSTOMER(C_NATIONKEY,C_CUSTKEY); \u6267\u884c\u8ba1\u5212 \u628a\u63a8\u8350\u51fa\u7684\u7d22\u5f15\u7eb3\u5165\u4f18\u5316\u5668\u89c4\u5212\u8303\u56f4\u540e\u7684\u6267\u884c\u8ba1\u5212\u4e3a\uff1a PostgreSQL\u4e0a\u7684\u6267\u884c\u8ba1\u5212 Nested Loop (cost=0.57..85.53 rows=33 width=4) -> Index Only Scan using paw_idx1196677611 on customer (cost=0.29..8.86 rows=33 width=4) Index Cond: (c_nationkey < 20) -> Index Only Scan using paw_idx1028958902 on orders (cost=0.29..2.24 rows=8 width=4) Index Cond: (o_custkey = customer.c_custkey) MySQL\u4e0a\u7684\u6267\u884c\u8ba1\u5212 -> Nested loop inner join (cost=1.91 rows=6) -> Filter: (customer.C_NATIONKEY < 20) (cost=0.35 rows=1) -> Index scan on customer using PAW_IDX1360881332 (cost=0.35 rows=1) -> Covering index lookup on orders using PAW_IDX1028958902 (O_CUSTKEY=customer.C_CUSTKEY) (cost=1.56 rows=6) \u53ef\u4ee5\u770b\u5230\uff0c\u901a\u8fc7PawSQL\u7684\u6574\u4e2a\u4f18\u5316\u6d41\u7a0b\uff0c\u901a\u8fc7\u7d22\u5f15\u63a8\u8350\u5f15\u64ce\u63a8\u8350\u7684\u4e24\u4e2a\u7d22\u5f15\uff0c\u5728\u6570\u636e\u91cf\u8f83\u5c0f\u7684PostgreSQL\u6570\u636e\u5e93\u4e0a\uff0c\u67e5\u8be2\u7684\u4ee3\u4ef7\u4ece410.47\u51cf\u4f4e\u523085.53\uff0c\u6027\u80fd\u63d0\u5347\u4e86379.91%\u3002\u800c\u5728\u6570\u636e\u91cf\u8f83\u5927\u7684MySQL\u6570\u636e\u5e93\u670d\u52a1\u5668\u4e0a\uff0c\u67e5\u8be2\u4ee3\u4ef7\u4ece20541.08\u964d\u4f4e\u52301.91\uff0c\u6027\u80fd\u63d0\u5347\u4e86553161.15%\u3002 \u9898\u5916\u8bdd\uff1a\u6d4b\u8bd5\u8fd9\u4e2a\u529f\u80fd\u662f\uff0c\u53d1\u73b0\u4e00\u4e2a\u77e5\u8bc6\u70b9\uff0c\u5728MySQL\u4e2d\uff0c\u5982\u679c\u67d0\u4e2a\u5b57\u6bb5\u88ab\u5b9a\u4e49\u4e3a\u5916\u952e\uff0c\u9ed8\u8ba4\u4f1a\u6709\u5bf9\u5e94\u7684\u7d22\u5f15\u5efa\u7acb\u5728\u4e0a\u9762\uff1b\u800c\u5728PostgreSQL\u7cfb\u5217\u7684\u6570\u636e\u5e93\u4e2d\uff0c\u5c06\u67d0\u4e9b\u5b57\u6bb5\u8bbe\u7f6e\u5916\u952e\u5e76\u4e0d\u4f1a\u81ea\u52a8\u5728\u8fd9\u4e9b\u5b57\u6bb5\u4e0a\u5efa\u4e0a\u7d22\u5f15\u3002","title":"PawSQL\u4e2d\u7684\u5916\u8fde\u63a5\u91cd\u5199\u4f18\u5316"},{"location":"pawreference/Outer2Inner/#_6","text":"\u90ae\u4ef6\uff1a service@pawsql.com Twitter: https://twitter.com/pawsql \u626b\u63cf\u5173\u6ce8PawSQL\u516c\u4f17\u53f7","title":"\u8054\u7cfb\u6211\u4eec"},{"location":"pawreference/Projection%20Pushdown/","text":"Projection Pushdown \u00b6 Channel of advanced SQL tuning Definition \u00b6 By enabling Projection Pushdown rule, PawSQL eliminates the columns in derived tables, common table expressions and views(after resolving), which are not referenced in outer query blocks, to: - reduce the IO cost - reduce the network cost - enable index recommendation of index-only strategy This justification is similar to rule [RuleStarInSelectList], but PawSQL supplies a rewrite optimization instead of only warning for star in select list scenario. We will use derived table in following paragraph, but all the descriptions also apply to common table expressions and resolved views. Conditions \u00b6 There is no star , except for count(*) , in outer query block, There is no star in the derived table or the common table expression being projection-pushdowned There are some select elements in a derived table or a common table expression which are not referenced in outer query block. Example \u00b6 Derived Table original query select c.c_name, sum(o_totalprice) price FROM customer c, (select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query select c.c_name, sum(dt.o_totalprice) as price from customer as c, ( select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) as dt where c.c_custkey = dt.o_custkey group by c.c_name Common Table Expression original query with dt as ( select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) select c.c_name, sum(o_totalprice) price from customer c, dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query with dt as (select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) select c.c_name, sum(dt.o_totalprice) as price from customer as c, dt where c.c_custkey = dt.o_custkey group by c.c_name Optimization Enablements \u00b6 Projection Pushdown will enable other optimizations in PawSQL and in database engine: Optimizations enabled in PawSQL index recommendation of index-only strategy Optimizations enabled in Database engine index only access in query plan","title":"Projection Pushdown"},{"location":"pawreference/Projection%20Pushdown/#projection-pushdown","text":"Channel of advanced SQL tuning","title":"Projection Pushdown"},{"location":"pawreference/Projection%20Pushdown/#definition","text":"By enabling Projection Pushdown rule, PawSQL eliminates the columns in derived tables, common table expressions and views(after resolving), which are not referenced in outer query blocks, to: - reduce the IO cost - reduce the network cost - enable index recommendation of index-only strategy This justification is similar to rule [RuleStarInSelectList], but PawSQL supplies a rewrite optimization instead of only warning for star in select list scenario. We will use derived table in following paragraph, but all the descriptions also apply to common table expressions and resolved views.","title":"Definition"},{"location":"pawreference/Projection%20Pushdown/#conditions","text":"There is no star , except for count(*) , in outer query block, There is no star in the derived table or the common table expression being projection-pushdowned There are some select elements in a derived table or a common table expression which are not referenced in outer query block.","title":"Conditions"},{"location":"pawreference/Projection%20Pushdown/#example","text":"Derived Table original query select c.c_name, sum(o_totalprice) price FROM customer c, (select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query select c.c_name, sum(dt.o_totalprice) as price from customer as c, ( select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) as dt where c.c_custkey = dt.o_custkey group by c.c_name Common Table Expression original query with dt as ( select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) select c.c_name, sum(o_totalprice) price from customer c, dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query with dt as (select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) select c.c_name, sum(dt.o_totalprice) as price from customer as c, dt where c.c_custkey = dt.o_custkey group by c.c_name","title":"Example"},{"location":"pawreference/Projection%20Pushdown/#optimization-enablements","text":"Projection Pushdown will enable other optimizations in PawSQL and in database engine: Optimizations enabled in PawSQL index recommendation of index-only strategy Optimizations enabled in Database engine index only access in query plan","title":"Optimization Enablements"},{"location":"pawreference/Query%20Folding/","text":"Query Folding \u00b6 Channel of advanced SQL tuning Definition \u00b6 By enabling Query Folding rule, PawSQL merges view references, derived tables and common table expressions to outer query blocks to: - avoid materializing intermediate resultset - enable more join order planning - enable more opportunities for index recommendation We will use view in following paragraph, but all the descriptions also apply to derived tables and common table expressions. Example - original query SELECT * FROM (SELECT c_custkey, c_name FROM customer) AS derived_t1; rewritten query SELECT c_custkey, c_name FROM customer Conditions \u00b6 PawSQL rewrite engine supports two types of query folding strategies, Type 1 - In view itself, there is no distinct or aggregation. - In outer query block, view being folded is not part of an outer join. Type 2 - In outer query block, the view is the only table reference - In outer query block, there is no group by clause and no aggregate functions. Examples \u00b6 Type 1 Query Folding \u00b6 Original query with dt as ( SELECT o_custkey, O_TOTALPRICE FROM orders where o_shippriority=0 ) select c.c_name, sum(O_TOTALPRICE) price FROM customer c, dt WHERE c.c_custkey = dt.o_custkey group by c.c_name Query plan of original query -> Table scan on < temporary > -> Aggregate using temporary table -> Nested loop inner join ( cost = 3806388 . 23 rows = 3400871 ) -> Table scan on dt ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Materialize CTE dt ( cost = 62935 . 41 .. 65430 . 12 rows = 199378 ) -> Table scan on < temporary > ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Temporary table with deduplication ( cost = 40502 . 89 .. 42997 . 60 rows = 199378 ) -> Table scan on orders ( cost = 20565 . 07 rows = 199378 ) -> Index lookup on c using PAW_IDX1614428511 ( C_CUSTKEY = dt . o_custkey ) ( cost = 17 . 06 rows = 17 ) Optimized query select c.c_name, sum(o_totalprice) as price FROM customer c, orders WHERE c.c_custkey = o_custkey and o_shippriority=0 group by c.c_name Query plan of optimized query -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=394660.89 rows=340087) -> Filter: (orders.O_SHIPPRIORITY = 0) (cost=20565.07 rows=19938) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explaination: We can see there is a Materialization step in the query plan of original query, which results from a huge cost. After the rewrite, the materialization step is elimnated and the estimated cost is aboutt 10% of the orignal cost. Type 2 Query Folding \u00b6 Original query with dt as (select c.c_name, sum(O_TOTALPRICE) price FROM customer c, orders WHERE c.c_custkey = orders.o_custkey group by c.c_name) select dt.price from dt where dt.c_name like '139%'; Query plan of original query -> Table scan on dt (cost=2.50..2.50 rows=0) -> Materialize CTE dt (cost=2.50..2.50 rows=0) -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=377837) -> Table scan on orders (cost=20565.07 rows=199378) -> Filter: (c.C_NAME like '139%') (cost=17.06 rows=2) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimized query select sum(orders.O_TOTALPRICE) from customer as c, orders where c.c_custkey = orders.o_custkey group by c.c_name having c.c_name like '139%' Query plan of optimized query -> Filter: (c.C_NAME like '139%') -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=3400871) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explanation: Like type 1, we can see the materialization step is eliminated after the rewrite optimization. Optimization Enablements \u00b6 View folding will reduce blocks by combining conditions or introducing table joins, which will enable other optimizations in PawSQL and optimizations in database engine: Optimizations enabled in PawSQL more efficient index recommendation Optimizations enabled in Database engine avoiding materializing intermediate resultset more join order planning index usage Let's take the type 1 case as an example, PawSQL Index Advisor engine takes the rewritten query as input and recommended a following index. CREATE INDEX PAW_IDX1564931998 ON TPCH . ORDERS ( O_SHIPPRIORITY , O_CUSTKEY , O_TOTALPRICE ); And the final query plan is as follows. -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=95046.40 rows=85935) -> Covering index lookup on orders using PAW_IDX1564931998 (O_SHIPPRIORITY=0) (cost=517.68 rows=5038) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) In the query plan, we can see we eliminates a table scan, and the estimated cost is further reduced to 95046.40 , which is about 2.5% of the original cost 3806388.23 .","title":"Query Folding"},{"location":"pawreference/Query%20Folding/#query-folding","text":"Channel of advanced SQL tuning","title":"Query Folding"},{"location":"pawreference/Query%20Folding/#definition","text":"By enabling Query Folding rule, PawSQL merges view references, derived tables and common table expressions to outer query blocks to: - avoid materializing intermediate resultset - enable more join order planning - enable more opportunities for index recommendation We will use view in following paragraph, but all the descriptions also apply to derived tables and common table expressions. Example - original query SELECT * FROM (SELECT c_custkey, c_name FROM customer) AS derived_t1; rewritten query SELECT c_custkey, c_name FROM customer","title":"Definition"},{"location":"pawreference/Query%20Folding/#conditions","text":"PawSQL rewrite engine supports two types of query folding strategies, Type 1 - In view itself, there is no distinct or aggregation. - In outer query block, view being folded is not part of an outer join. Type 2 - In outer query block, the view is the only table reference - In outer query block, there is no group by clause and no aggregate functions.","title":"Conditions"},{"location":"pawreference/Query%20Folding/#examples","text":"","title":"Examples"},{"location":"pawreference/Query%20Folding/#type-1-query-folding","text":"Original query with dt as ( SELECT o_custkey, O_TOTALPRICE FROM orders where o_shippriority=0 ) select c.c_name, sum(O_TOTALPRICE) price FROM customer c, dt WHERE c.c_custkey = dt.o_custkey group by c.c_name Query plan of original query -> Table scan on < temporary > -> Aggregate using temporary table -> Nested loop inner join ( cost = 3806388 . 23 rows = 3400871 ) -> Table scan on dt ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Materialize CTE dt ( cost = 62935 . 41 .. 65430 . 12 rows = 199378 ) -> Table scan on < temporary > ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Temporary table with deduplication ( cost = 40502 . 89 .. 42997 . 60 rows = 199378 ) -> Table scan on orders ( cost = 20565 . 07 rows = 199378 ) -> Index lookup on c using PAW_IDX1614428511 ( C_CUSTKEY = dt . o_custkey ) ( cost = 17 . 06 rows = 17 ) Optimized query select c.c_name, sum(o_totalprice) as price FROM customer c, orders WHERE c.c_custkey = o_custkey and o_shippriority=0 group by c.c_name Query plan of optimized query -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=394660.89 rows=340087) -> Filter: (orders.O_SHIPPRIORITY = 0) (cost=20565.07 rows=19938) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explaination: We can see there is a Materialization step in the query plan of original query, which results from a huge cost. After the rewrite, the materialization step is elimnated and the estimated cost is aboutt 10% of the orignal cost.","title":"Type 1 Query Folding"},{"location":"pawreference/Query%20Folding/#type-2-query-folding","text":"Original query with dt as (select c.c_name, sum(O_TOTALPRICE) price FROM customer c, orders WHERE c.c_custkey = orders.o_custkey group by c.c_name) select dt.price from dt where dt.c_name like '139%'; Query plan of original query -> Table scan on dt (cost=2.50..2.50 rows=0) -> Materialize CTE dt (cost=2.50..2.50 rows=0) -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=377837) -> Table scan on orders (cost=20565.07 rows=199378) -> Filter: (c.C_NAME like '139%') (cost=17.06 rows=2) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimized query select sum(orders.O_TOTALPRICE) from customer as c, orders where c.c_custkey = orders.o_custkey group by c.c_name having c.c_name like '139%' Query plan of optimized query -> Filter: (c.C_NAME like '139%') -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=3400871) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explanation: Like type 1, we can see the materialization step is eliminated after the rewrite optimization.","title":"Type 2 Query Folding"},{"location":"pawreference/Query%20Folding/#optimization-enablements","text":"View folding will reduce blocks by combining conditions or introducing table joins, which will enable other optimizations in PawSQL and optimizations in database engine: Optimizations enabled in PawSQL more efficient index recommendation Optimizations enabled in Database engine avoiding materializing intermediate resultset more join order planning index usage Let's take the type 1 case as an example, PawSQL Index Advisor engine takes the rewritten query as input and recommended a following index. CREATE INDEX PAW_IDX1564931998 ON TPCH . ORDERS ( O_SHIPPRIORITY , O_CUSTKEY , O_TOTALPRICE ); And the final query plan is as follows. -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=95046.40 rows=85935) -> Covering index lookup on orders using PAW_IDX1564931998 (O_SHIPPRIORITY=0) (cost=517.68 rows=5038) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) In the query plan, we can see we eliminates a table scan, and the estimated cost is further reduced to 95046.40 , which is about 2.5% of the original cost 3806388.23 .","title":"Optimization Enablements"},{"location":"pawreference/RuleQueryFoldingRewrite/","text":"Query Folding \u00b6 Channel of advanced SQL tuning Definition \u00b6 By enabling Query Folding rule, PawSQL merges view references, derived tables and common table expressions to outer query blocks to: - avoid materializing intermediate resultset - enable more join order planning - enable more opportunities for index recommendation We will use view in following paragraph, but all the descriptions also apply to derived tables and common table expressions. Example - original query SELECT * FROM (SELECT c_custkey, c_name FROM customer) AS derived_t1; rewritten query SELECT c_custkey, c_name FROM customer Conditions \u00b6 PawSQL rewrite engine supports two types of query folding strategies, Type 1 - In view itself, there is no distinct or aggregation. - In outer query block, view being folded is not part of an outer join. Type 2 - In outer query block, the view is the only table reference - In outer query block, there is no group by clause and no aggregate functions. Examples \u00b6 Type 1 Query Folding \u00b6 Original query with dt as ( SELECT o_custkey, O_TOTALPRICE FROM orders where o_shippriority=0 ) select c.c_name, sum(O_TOTALPRICE) price FROM customer c, dt WHERE c.c_custkey = dt.o_custkey group by c.c_name Query plan of original query -> Table scan on < temporary > -> Aggregate using temporary table -> Nested loop inner join ( cost = 3806388 . 23 rows = 3400871 ) -> Table scan on dt ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Materialize CTE dt ( cost = 62935 . 41 .. 65430 . 12 rows = 199378 ) -> Table scan on < temporary > ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Temporary table with deduplication ( cost = 40502 . 89 .. 42997 . 60 rows = 199378 ) -> Table scan on orders ( cost = 20565 . 07 rows = 199378 ) -> Index lookup on c using PAW_IDX1614428511 ( C_CUSTKEY = dt . o_custkey ) ( cost = 17 . 06 rows = 17 ) Optimized query select c.c_name, sum(o_totalprice) as price FROM customer c, orders WHERE c.c_custkey = o_custkey and o_shippriority=0 group by c.c_name Query plan of optimized query -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=394660.89 rows=340087) -> Filter: (orders.O_SHIPPRIORITY = 0) (cost=20565.07 rows=19938) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explaination: We can see there is a Materialization step in the query plan of original query, which results from a huge cost. After the rewrite, the materialization step is elimnated and the estimated cost is aboutt 10% of the orignal cost. Type 2 Query Folding \u00b6 Original query with dt as (select c.c_name, sum(O_TOTALPRICE) price FROM customer c, orders WHERE c.c_custkey = orders.o_custkey group by c.c_name) select dt.price from dt where dt.c_name like '139%'; Query plan of original query -> Table scan on dt (cost=2.50..2.50 rows=0) -> Materialize CTE dt (cost=2.50..2.50 rows=0) -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=377837) -> Table scan on orders (cost=20565.07 rows=199378) -> Filter: (c.C_NAME like '139%') (cost=17.06 rows=2) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimized query select sum(orders.O_TOTALPRICE) from customer as c, orders where c.c_custkey = orders.o_custkey group by c.c_name having c.c_name like '139%' Query plan of optimized query -> Filter: (c.C_NAME like '139%') -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=3400871) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explanation: Like type 1, we can see the materialization step is eliminated after the rewrite optimization. Optimization Enablements \u00b6 View folding will reduce blocks by combining conditions or introducing table joins, which will enable other optimizations in PawSQL and optimizations in database engine: Optimizations enabled in PawSQL more efficient index recommendation Optimizations enabled in Database engine avoiding materializing intermediate resultset more join order planning index usage Let's take the type 1 case as an example, PawSQL Index Advisor engine takes the rewritten query as input and recommended a following index. CREATE INDEX PAW_IDX1564931998 ON TPCH . ORDERS ( O_SHIPPRIORITY , O_CUSTKEY , O_TOTALPRICE ); And the final query plan is as follows. -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=95046.40 rows=85935) -> Covering index lookup on orders using PAW_IDX1564931998 (O_SHIPPRIORITY=0) (cost=517.68 rows=5038) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) In the query plan, we can see we eliminates a table scan, and the estimated cost is further reduced to 95046.40 , which is about 2.5% of the original cost 3806388.23 .","title":"Query Folding Rewrite"},{"location":"pawreference/RuleQueryFoldingRewrite/#query-folding","text":"Channel of advanced SQL tuning","title":"Query Folding"},{"location":"pawreference/RuleQueryFoldingRewrite/#definition","text":"By enabling Query Folding rule, PawSQL merges view references, derived tables and common table expressions to outer query blocks to: - avoid materializing intermediate resultset - enable more join order planning - enable more opportunities for index recommendation We will use view in following paragraph, but all the descriptions also apply to derived tables and common table expressions. Example - original query SELECT * FROM (SELECT c_custkey, c_name FROM customer) AS derived_t1; rewritten query SELECT c_custkey, c_name FROM customer","title":"Definition"},{"location":"pawreference/RuleQueryFoldingRewrite/#conditions","text":"PawSQL rewrite engine supports two types of query folding strategies, Type 1 - In view itself, there is no distinct or aggregation. - In outer query block, view being folded is not part of an outer join. Type 2 - In outer query block, the view is the only table reference - In outer query block, there is no group by clause and no aggregate functions.","title":"Conditions"},{"location":"pawreference/RuleQueryFoldingRewrite/#examples","text":"","title":"Examples"},{"location":"pawreference/RuleQueryFoldingRewrite/#type-1-query-folding","text":"Original query with dt as ( SELECT o_custkey, O_TOTALPRICE FROM orders where o_shippriority=0 ) select c.c_name, sum(O_TOTALPRICE) price FROM customer c, dt WHERE c.c_custkey = dt.o_custkey group by c.c_name Query plan of original query -> Table scan on < temporary > -> Aggregate using temporary table -> Nested loop inner join ( cost = 3806388 . 23 rows = 3400871 ) -> Table scan on dt ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Materialize CTE dt ( cost = 62935 . 41 .. 65430 . 12 rows = 199378 ) -> Table scan on < temporary > ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Temporary table with deduplication ( cost = 40502 . 89 .. 42997 . 60 rows = 199378 ) -> Table scan on orders ( cost = 20565 . 07 rows = 199378 ) -> Index lookup on c using PAW_IDX1614428511 ( C_CUSTKEY = dt . o_custkey ) ( cost = 17 . 06 rows = 17 ) Optimized query select c.c_name, sum(o_totalprice) as price FROM customer c, orders WHERE c.c_custkey = o_custkey and o_shippriority=0 group by c.c_name Query plan of optimized query -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=394660.89 rows=340087) -> Filter: (orders.O_SHIPPRIORITY = 0) (cost=20565.07 rows=19938) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explaination: We can see there is a Materialization step in the query plan of original query, which results from a huge cost. After the rewrite, the materialization step is elimnated and the estimated cost is aboutt 10% of the orignal cost.","title":"Type 1 Query Folding"},{"location":"pawreference/RuleQueryFoldingRewrite/#type-2-query-folding","text":"Original query with dt as (select c.c_name, sum(O_TOTALPRICE) price FROM customer c, orders WHERE c.c_custkey = orders.o_custkey group by c.c_name) select dt.price from dt where dt.c_name like '139%'; Query plan of original query -> Table scan on dt (cost=2.50..2.50 rows=0) -> Materialize CTE dt (cost=2.50..2.50 rows=0) -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=377837) -> Table scan on orders (cost=20565.07 rows=199378) -> Filter: (c.C_NAME like '139%') (cost=17.06 rows=2) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimized query select sum(orders.O_TOTALPRICE) from customer as c, orders where c.c_custkey = orders.o_custkey group by c.c_name having c.c_name like '139%' Query plan of optimized query -> Filter: (c.C_NAME like '139%') -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=3400871) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explanation: Like type 1, we can see the materialization step is eliminated after the rewrite optimization.","title":"Type 2 Query Folding"},{"location":"pawreference/RuleQueryFoldingRewrite/#optimization-enablements","text":"View folding will reduce blocks by combining conditions or introducing table joins, which will enable other optimizations in PawSQL and optimizations in database engine: Optimizations enabled in PawSQL more efficient index recommendation Optimizations enabled in Database engine avoiding materializing intermediate resultset more join order planning index usage Let's take the type 1 case as an example, PawSQL Index Advisor engine takes the rewritten query as input and recommended a following index. CREATE INDEX PAW_IDX1564931998 ON TPCH . ORDERS ( O_SHIPPRIORITY , O_CUSTKEY , O_TOTALPRICE ); And the final query plan is as follows. -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=95046.40 rows=85935) -> Covering index lookup on orders using PAW_IDX1564931998 (O_SHIPPRIORITY=0) (cost=517.68 rows=5038) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) In the query plan, we can see we eliminates a table scan, and the estimated cost is further reduced to 95046.40 , which is about 2.5% of the original cost 3806388.23 .","title":"Optimization Enablements"},{"location":"pawreference/audit-rules/","text":"Auditing Rules \u00b6 The auditing rules is from the industry's best practices for query optimization for relational databases. Update with limit \u00b6 Update statements with limit clause can lead to unexpected operation results among multiple runs or slave relay, especailly under a multi-server senario. Postive Case Negative Case update customer set c_custkey = 100 where c_name = 'Ray' limit 1 ; -- Vilation: true update customer set c_custkey = 100 where not c_phone is null ; -- Vilation: false LIMIT with ORDER BY \u00b6 LIMIT queries without ORDER BY clause can result in inconsistent results among multiple executions. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; -- Vilation: false No condidtions for DML statements \u00b6 For Update/merge/delete statements without WHERE condition, or with a condition of where 1=1 , the data malpulation operations will be applied to all rows in the table, which is dangerose and may cause performance issues. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; - Vilation : false INSERT without column names \u00b6 The insert statements should specify column name which can reduce the possibility of misalignment between the inserted values and the columns of the result table. [CASES TO BE ADDED] Avoid starting with wildcard in a LIKE predicate; \u00b6 Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED] Avoid using functional operations on conditional fields; \u00b6 Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED] Avoid implicit conversions on conditional fields; \u00b6 Conditional fields have implicit conversions of numeric values and characters; Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED] Avoid SELECT * \u00b6 The select * syntax is not recommended; Affects subsequent optimization logic and is difficult to maintain. [CASES TO BE ADDED] The level of nested queries exceed the specified threshold \u00b6 SQL that is too complex affects the performance of the plan and is prone to poor performance execution plans. the default value of threshold is 2. [CASES TO BE ADDED] The number of tables in one query block using should not to exceed the threshold \u00b6 SQL that is too complex affects the performance of plan generation and is prone to poor performance execution plans. The default value of threshold is 5. [CASES TO BE ADDED] Use select with \"for update\"\uff1b \u00b6 For update lock tables or lock records. [CASES TO BE ADDED] The number of values of insert statement not exceeding the threshold (default is 500) \u00b6 [CASES TO BE ADDED] Query statements without conditions \u00b6 SQL statements without \"where\" conditions, or with \"where 1=1\", etc, are used, and there are no group aggregation and limit statements. [CASES TO BE ADDED] UNION to UNION ALL rewrite \u00b6 Unions need to be grouped and deduplication, which affects performance. [CASES TO BE ADDED]","title":"Auditing Rules"},{"location":"pawreference/audit-rules/#auditing-rules","text":"The auditing rules is from the industry's best practices for query optimization for relational databases.","title":"Auditing Rules"},{"location":"pawreference/audit-rules/#update-with-limit","text":"Update statements with limit clause can lead to unexpected operation results among multiple runs or slave relay, especailly under a multi-server senario. Postive Case Negative Case update customer set c_custkey = 100 where c_name = 'Ray' limit 1 ; -- Vilation: true update customer set c_custkey = 100 where not c_phone is null ; -- Vilation: false","title":"Update with limit"},{"location":"pawreference/audit-rules/#limit-with-order-by","text":"LIMIT queries without ORDER BY clause can result in inconsistent results among multiple executions. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; -- Vilation: false","title":"LIMIT with ORDER BY"},{"location":"pawreference/audit-rules/#no-condidtions-for-dml-statements","text":"For Update/merge/delete statements without WHERE condition, or with a condition of where 1=1 , the data malpulation operations will be applied to all rows in the table, which is dangerose and may cause performance issues. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; - Vilation : false","title":"No condidtions for DML statements"},{"location":"pawreference/audit-rules/#insert-without-column-names","text":"The insert statements should specify column name which can reduce the possibility of misalignment between the inserted values and the columns of the result table. [CASES TO BE ADDED]","title":"INSERT without column names"},{"location":"pawreference/audit-rules/#avoid-starting-with-wildcard-in-a-like-predicate","text":"Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED]","title":"Avoid starting with wildcard in a LIKE predicate;"},{"location":"pawreference/audit-rules/#avoid-using-functional-operations-on-conditional-fields","text":"Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED]","title":"Avoid using functional operations on conditional fields;"},{"location":"pawreference/audit-rules/#avoid-implicit-conversions-on-conditional-fields","text":"Conditional fields have implicit conversions of numeric values and characters; Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED]","title":"Avoid implicit conversions on conditional fields;"},{"location":"pawreference/audit-rules/#avoid-select","text":"The select * syntax is not recommended; Affects subsequent optimization logic and is difficult to maintain. [CASES TO BE ADDED]","title":"Avoid SELECT *"},{"location":"pawreference/audit-rules/#the-level-of-nested-queries-exceed-the-specified-threshold","text":"SQL that is too complex affects the performance of the plan and is prone to poor performance execution plans. the default value of threshold is 2. [CASES TO BE ADDED]","title":"The level of nested queries exceed the specified threshold"},{"location":"pawreference/audit-rules/#the-number-of-tables-in-one-query-block-using-should-not-to-exceed-the-threshold","text":"SQL that is too complex affects the performance of plan generation and is prone to poor performance execution plans. The default value of threshold is 5. [CASES TO BE ADDED]","title":"The number of tables in one query block using should not to exceed the threshold"},{"location":"pawreference/audit-rules/#use-select-with-for-update","text":"For update lock tables or lock records. [CASES TO BE ADDED]","title":"Use select with \"for update\"\uff1b"},{"location":"pawreference/audit-rules/#the-number-of-values-of-insert-statement-not-exceeding-the-threshold-default-is-500","text":"[CASES TO BE ADDED]","title":"The number of values of insert statement not exceeding the threshold (default is 500)"},{"location":"pawreference/audit-rules/#query-statements-without-conditions","text":"SQL statements without \"where\" conditions, or with \"where 1=1\", etc, are used, and there are no group aggregation and limit statements. [CASES TO BE ADDED]","title":"Query statements without conditions"},{"location":"pawreference/audit-rules/#union-to-union-all-rewrite","text":"Unions need to be grouped and deduplication, which affects performance. [CASES TO BE ADDED]","title":"UNION to UNION ALL rewrite"},{"location":"pawreference/datatype-mismatching/","text":"Implicit Data Type Conversion \u00b6 Channel of advanced SQL tuning Problem \u00b6 Let's say the O_ORDERDATE column in TPCH.ORDERS table is defined as VARCHAR(16) , and there is an index ORDDATE_IDX on ORDERS(O_ORDERDATE) to accelerate the queries against this table if there is a condition on O_ORDERDATE . If we want to count the number of orders of today using following SQL query. select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Use explain to get the query plan: -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) From the query plan, we can see the database optimizer uses a table scan instead of the index lookup as we expected. The query cost is high. Diagnosis \u00b6 Let's replace the function call current_date() with a string value '2022-09-08' , select count ( * ) from ORDERS where O_ORDERDATE = '2022-09-08' ; Use explain to get the query plan: -> Aggregate : count ( 0 ) ( cost = 0 . 50 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) -> Covering index lookup on ORDERS using PAW_IDX1264424863 ( O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) From the query plan , we can see the database optimizer chooses index lookup using index ORDDATE_IDX and the cost is less than 1% of the previous SQL query. Diagnosis: The problem is because of the implicit data type conversion applied on O_ORDERDATE and this conversion disables the index application. When the data types of expressions in a predicate are different, there will be some implicit data type convention operations during query execution (MySQL) 1 . For implicit conventions, some times it happens to the constants in the predicate, sometimes it happens to the column in the predicate. When the convention is applied on the column, the candidate indexes will not be considered during query execution and leading to serious performance problems. Solution \u00b6 The straightful solution is to ensure the expressions used in filtering conditions have the same data type to the column's. For the problematic SQL query, 1. we can either define the O_ORDERDATE as DATE type, or we can use type conversion function cast to make sure the filtering constant with the same data type of column. But both solutions are very prone to mis-usage and time consuming, because the developers need to have the knowledge and check the table definitions from time to time. That is where the query tuning tool, such as PawSQL, fills in. PawSQL auto-rewrites \u00b6 There is a rewrite optimization rule [DiffDataTypeInPredicateRewrite] in PawSQL to automatically detect the data type mis-matching in SQL queries and provide automatic rewrite optmization. Conditions \u00b6 The predicate is between a table column and simple value expressions 2 The table column has a different data type from the simple value expressions. Support following three type of predicates column operator expr column between expr1 and expr2 column in ( expr1 , expr2 , ) Example Cases \u00b6 Case 1 : column operator expr - Input Query select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Query Plan for input query -> Aggregate : count ( orders . O_CUSTKEY ) ( cost = 4614 . 83 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) Optimized Query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE = cast ( current_date () as CHAR ( 16 )); Query Plan for the optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 20 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on ORDERS using o_orderdate_idx ( O_ORDERDATE = cast ( curdate () as char ( 16 ) charset utf8mb4 )) ( cost = 1 . 10 rows = 1 ) Optimization Explanation: O_ORDERDATE is type of CHAR(16) in table definition, and current_date() is type of DATE , so index on O_ORDERDATE is not applicable, and the estimated cost is 4614.83 . PawSQL rewrites current_date() to cast(current_date() as CHAR(16)) , so the index on O_ORDERDATE is chosen by the database optimizer and the cost is reduce to 1.20 , which is less than 0.1%. Case 2 : column between expr1 and expr2 - Input query select count ( * ) from ORDERS where O_ORDERDATE between current_date () and DATE_ADD ( CURRENT_DATE (), INTERVAL 1 DAY ); - Query plan for input query -> Aggregate : count ( orders . O_ORDERKEY ) ( cost = 5057 . 45 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( curdate ()) and < cache > (( curdate () + interval 1 day ))) ( cost = 2842 . 36 rows = 22151 ) -> Table scan on ORDERS ( cost = 2842 . 36 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE between cast ( current_date () as CHAR ( 16 )) and cast ( DATE_ADD ( CURRENT_DATE (), interval '1' DAY ) as CHAR ( 16 )) - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 31 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )) and < cache > ( cast (( curdate () + interval '1' day ) as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 21 rows = 1 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( '2022-09-14' <= O_ORDERDATE <= '2022-09-15' ) ( cost = 1 . 21 rows = 1 ) __Optimization Explanation:__ `DATE_ADD(CURRENT_DATE(), INTERVAL 1 DAY)` is a nested function and it's final result is type of `DATE`, which is not compatible with `CHAR(16)`. So it's rewritten to cast(DATE_ADD(CURRENT_DATE(), interval '1' DAY) as CHAR(16)). And the cost is reduced to ***1.31*** from ***5057.45***. Case 3 : column in ( expr1 , expr2 , ...) - Input query select count ( * ) from ORDERS where O_ORDERDATE in ( current_date (), '2022-10-01' ); - Query Plan for input query -> Aggregate : count ( 0 ) ( cost = 8602 . 39 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( curdate ()), '2022-10-01' )) ( cost = 4614 . 83 rows = 39876 ) -> Index scan on ORDERS using o_orderdate_idx ( cost = 4614 . 83 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE in ( cast ( current_date () as CHAR ( 16 )), '2022-10-01' ); - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 62 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )), '2022-10-01' )) ( cost = 1 . 42 rows = 2 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( O_ORDERDATE = '2022-09-14' ) OR ( O_ORDERDATE = '2022-10-01' ) ( cost = 1 . 42 rows = 2 ) __Optimization Explanation:__ `current_date()` is written to `cast(current_date() as CHAR(16))`, and `'2022-10-01'` is type of character string, which is compatible with the type of column `O_ORDERDATE`. It is no need to rewrite it. And the cost is reduced to ***1.62*** from ***8602.39***. For PostgreSQL, instead of applying data type conversion implicitly, there will be an error thrown by the database to notify users there should be some explicit type conventions to add. \u21a9 Simple value expressions refer to constants or expressions/functions which are evaluated to a constant, such as current_date() , 1 + 2 , concate('first name', 'last name') . \u21a9","title":"Datatype Mismatching Rewrite"},{"location":"pawreference/datatype-mismatching/#implicit-data-type-conversion","text":"Channel of advanced SQL tuning","title":"Implicit Data Type Conversion"},{"location":"pawreference/datatype-mismatching/#problem","text":"Let's say the O_ORDERDATE column in TPCH.ORDERS table is defined as VARCHAR(16) , and there is an index ORDDATE_IDX on ORDERS(O_ORDERDATE) to accelerate the queries against this table if there is a condition on O_ORDERDATE . If we want to count the number of orders of today using following SQL query. select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Use explain to get the query plan: -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) From the query plan, we can see the database optimizer uses a table scan instead of the index lookup as we expected. The query cost is high.","title":"Problem"},{"location":"pawreference/datatype-mismatching/#diagnosis","text":"Let's replace the function call current_date() with a string value '2022-09-08' , select count ( * ) from ORDERS where O_ORDERDATE = '2022-09-08' ; Use explain to get the query plan: -> Aggregate : count ( 0 ) ( cost = 0 . 50 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) -> Covering index lookup on ORDERS using PAW_IDX1264424863 ( O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) From the query plan , we can see the database optimizer chooses index lookup using index ORDDATE_IDX and the cost is less than 1% of the previous SQL query. Diagnosis: The problem is because of the implicit data type conversion applied on O_ORDERDATE and this conversion disables the index application. When the data types of expressions in a predicate are different, there will be some implicit data type convention operations during query execution (MySQL) 1 . For implicit conventions, some times it happens to the constants in the predicate, sometimes it happens to the column in the predicate. When the convention is applied on the column, the candidate indexes will not be considered during query execution and leading to serious performance problems.","title":"Diagnosis"},{"location":"pawreference/datatype-mismatching/#solution","text":"The straightful solution is to ensure the expressions used in filtering conditions have the same data type to the column's. For the problematic SQL query, 1. we can either define the O_ORDERDATE as DATE type, or we can use type conversion function cast to make sure the filtering constant with the same data type of column. But both solutions are very prone to mis-usage and time consuming, because the developers need to have the knowledge and check the table definitions from time to time. That is where the query tuning tool, such as PawSQL, fills in.","title":"Solution"},{"location":"pawreference/datatype-mismatching/#pawsql-auto-rewrites","text":"There is a rewrite optimization rule [DiffDataTypeInPredicateRewrite] in PawSQL to automatically detect the data type mis-matching in SQL queries and provide automatic rewrite optmization.","title":"PawSQL auto-rewrites"},{"location":"pawreference/datatype-mismatching/#conditions","text":"The predicate is between a table column and simple value expressions 2 The table column has a different data type from the simple value expressions. Support following three type of predicates column operator expr column between expr1 and expr2 column in ( expr1 , expr2 , )","title":"Conditions"},{"location":"pawreference/datatype-mismatching/#example-cases","text":"Case 1 : column operator expr - Input Query select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Query Plan for input query -> Aggregate : count ( orders . O_CUSTKEY ) ( cost = 4614 . 83 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) Optimized Query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE = cast ( current_date () as CHAR ( 16 )); Query Plan for the optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 20 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on ORDERS using o_orderdate_idx ( O_ORDERDATE = cast ( curdate () as char ( 16 ) charset utf8mb4 )) ( cost = 1 . 10 rows = 1 ) Optimization Explanation: O_ORDERDATE is type of CHAR(16) in table definition, and current_date() is type of DATE , so index on O_ORDERDATE is not applicable, and the estimated cost is 4614.83 . PawSQL rewrites current_date() to cast(current_date() as CHAR(16)) , so the index on O_ORDERDATE is chosen by the database optimizer and the cost is reduce to 1.20 , which is less than 0.1%. Case 2 : column between expr1 and expr2 - Input query select count ( * ) from ORDERS where O_ORDERDATE between current_date () and DATE_ADD ( CURRENT_DATE (), INTERVAL 1 DAY ); - Query plan for input query -> Aggregate : count ( orders . O_ORDERKEY ) ( cost = 5057 . 45 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( curdate ()) and < cache > (( curdate () + interval 1 day ))) ( cost = 2842 . 36 rows = 22151 ) -> Table scan on ORDERS ( cost = 2842 . 36 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE between cast ( current_date () as CHAR ( 16 )) and cast ( DATE_ADD ( CURRENT_DATE (), interval '1' DAY ) as CHAR ( 16 )) - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 31 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )) and < cache > ( cast (( curdate () + interval '1' day ) as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 21 rows = 1 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( '2022-09-14' <= O_ORDERDATE <= '2022-09-15' ) ( cost = 1 . 21 rows = 1 ) __Optimization Explanation:__ `DATE_ADD(CURRENT_DATE(), INTERVAL 1 DAY)` is a nested function and it's final result is type of `DATE`, which is not compatible with `CHAR(16)`. So it's rewritten to cast(DATE_ADD(CURRENT_DATE(), interval '1' DAY) as CHAR(16)). And the cost is reduced to ***1.31*** from ***5057.45***. Case 3 : column in ( expr1 , expr2 , ...) - Input query select count ( * ) from ORDERS where O_ORDERDATE in ( current_date (), '2022-10-01' ); - Query Plan for input query -> Aggregate : count ( 0 ) ( cost = 8602 . 39 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( curdate ()), '2022-10-01' )) ( cost = 4614 . 83 rows = 39876 ) -> Index scan on ORDERS using o_orderdate_idx ( cost = 4614 . 83 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE in ( cast ( current_date () as CHAR ( 16 )), '2022-10-01' ); - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 62 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )), '2022-10-01' )) ( cost = 1 . 42 rows = 2 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( O_ORDERDATE = '2022-09-14' ) OR ( O_ORDERDATE = '2022-10-01' ) ( cost = 1 . 42 rows = 2 ) __Optimization Explanation:__ `current_date()` is written to `cast(current_date() as CHAR(16))`, and `'2022-10-01'` is type of character string, which is compatible with the type of column `O_ORDERDATE`. It is no need to rewrite it. And the cost is reduced to ***1.62*** from ***8602.39***. For PostgreSQL, instead of applying data type conversion implicitly, there will be an error thrown by the database to notify users there should be some explicit type conventions to add. \u21a9 Simple value expressions refer to constants or expressions/functions which are evaluated to a constant, such as current_date() , 1 + 2 , concate('first name', 'last name') . \u21a9","title":"Example Cases"},{"location":"pawreference/rewrite-rules/","text":"Optimization Overview \u00b6 Copyright \u00a9 2022 PawSQL Join Elimination \u00b6 Join Elimination is an optimization technique that simplifies SQL and improves query performance by removing joins from the query that do not affect the final result. Typically, this optimization can be applied when a query includes a primary-foreign key join and only references the primary key column of the parent table. Consider the following example: select o . * from orders o inner join customer c on c . c_custkey = o . o_custkey In this query, the orders table is joined with the customer table on the primary-foreign key relationship, and c_custkey is the primary key. Therefore, the customer table can be eliminated from the query, and the rewritten SQL would be: select * from orders where o_custkey Learn more about Join Elimination ; Outer2Inner Join Conversion \u00b6 Outer join optimization refers to the conversion of an outer join that satisfies certain conditions (the outer table has a NULL rejection condition) into an inner join, allowing the database optimizer to choose a more optimal execution plan and improve the performance of SQL queries. Consider the following example: select c_custkey from orders left join customer on c_custkey = o_custkey where C_NATIONKEY < 20 C_NATIONKEY < 20 is a NULL rejection condition on the customer table, so the left outer join can be rewritten as an inner join: select c_custkey from orders inner join customer on c_custkey = o_custkey where C_NATIONKEY < 20 Learn more about Outer2Inner Join Conversion . SAT-TC Rewrite \u00b6 SAT-TC (SATisfiability-Transitive Closure) rewrite optimization refers to analyzing a set of related query conditions to discover contradictory, to simplify, or to infer more conditions, helping the database optimizer choose a better execution plan to improve SQL performance. Consider the following example: select c . c_name FROM customer c where c . c_name = 'John' and c . c_name = 'Jessey' Because the conditions are contradictory, the rewritten SQL is: select c . c_name from customer as c where 1 = 0 Learn more about SAT-TC Rewrite . Query Folding \u00b6 Query folding refers to extending views, CTEs, or DT subqueries and merging them with the query statement that references them to reduce the serialization of intermediate result sets or trigger better optimization techniques for table joins. Consider the following example: SELECT * FROM ( SELECT c_custkey , c_name FROM customer ) AS derived_t1 ; The rewritten SQL is: SELECT c_custkey , c_name FROM customer Learn more about Query Folding . Projection Pushdown \u00b6 Projection pushdown removes useless columns (not used in the outer query) from DT subqueries to reduce the cost of I/O and network, while increasing the chances of adopting index-only optimization strategy to improve query performance. Consider the following example: SELECT count ( 1 ) FROM ( SELECT c_custkey , avg ( age ) FROM customer group by c_custkey ) AS derived_t1 ; The rewritten SQL is: SELECT count ( 1 ) FROM ( SELECT 1 FROM customer group by c_custkey ) AS derived_t1 ; Learn more about Projection Pushdown . Nullable IN-Subqueries Rewrite \u00b6 For the following SQL query which intends to find out customers without orders: select * from customer where c_custkey not in ( select o_custkey from orders ) If the result set of the subquery contains NULL rows, this SQL query will always return an empty result. The correct way is to add a is not null condition to the subquery, like this: select * from customer where c_custkey not in ( select o_custkey from orders where o_custkey is not null ) Learn more about Nullable IN Subqueries Rewrite . HAVING Condition Pushdown \u00b6 Logically, conditions on the HAVING clause are executed after GROUP BY , and the conditions on the WHERE clause can be executed during table access (index access) or after table access and before GROUP BY , which are less costly. Consider the following example: select c_custkey, count(*) from customer group by c_custkey having c_custkey < 100 The rewritten SQL is: select c_custkey , count ( * ) from customer where c_custkey < 100 group by c_custkey Learn more about HAVING Condition Pushdown . ALL Qualified Subqueries Rewrite \u00b6 Assuming the following SQL is used to obtain registered users after the order system is closed: select * from customer where c_regdate > all ( select o_orderdate from orders ) If there is a NULL value in the result of the subquery, this SQL always returns empty result. The correct method is to add a is not null condition in the subquery or rewrite to the max/min subquery. select * from customer where c_regdate > ( select max ( o_custkey ) from orders ) PawSQL uses the second. Learn more about ALL Qualified Subqueries Optimization . MAX/MIN Subquery Rewrite \u00b6 For subqueries that use MAX/MIN , such as select * from customer where c_custkey = ( select max ( o_custkey ) from orders ) can be rewritten in the following way to avoid aggregation and take advantage of the index's ordering: select * from customer where c_custkey = ( select o_custkey from orders order by o_custkey desc null last limit 1 ) Learn more about MAX/MIN Subquery Rewrite . COUNT SSQ Rewrite \u00b6 For the following scalar subquery(SSQ), select * from customer where (select count(*) from orders where c_custkey=o_custkey) > 0 it can be rewritten to following EXISTS query which avoids the aggregation: select * from customer where exists ( select 1 from orders where c_custkey = o_custkey ) Learn more about COUNT SSQ Optimization . Avoid using =NULL \u00b6 =null or case when null cannot judge whether the expression is null. To determine whether the expression is null, use is null . The appearance of =null or case when null in SQL is most likely an error made by developers because they are always judged as false, equivalent to 1=0. Therefore, PawSQL checks and reminds developers of this type of writing, and performs rewriting. For example, the following SQL, select case c_phone when null then 0 else 1 end from customer ; will be rewritten by PawSQL as select case when c_phone is null then 0 else 1 end from customer ; Learn more about Avoid using =NULL . Avoid Using SELECT * \u00b6 The disadvantages of using SELECT * in queries are as follows: If SELECT * contains unused large fields, especially TEXT / CLOB type fields, it is easy to cause unnecessary disk IO and network overhead. Using SELECT * increases the effort of maintenance, such as inconsistent with the resultMap configuration when adding or deleting fields, and incorrect field mapping when using insert into select * . The database optimizer cannot take advantage of the coverage index. PawSQL index recommendation cannot recommend coverage index. Learn more about Avoid Using SELECT * . Avoid Using Random Functions for Sorting \u00b6 MySQL's rand function or PostgreSQL's random function returns a random floating-point number between 0 and 1.0. Sometimes we use the following query statement to obtain a random sample of the data set. select * from orders order by rand () limit 1 ; If the customer table has fewer than 10,000 rows, this method works well. But when you have 1,000,000 rows, the cost of sorting becomes unacceptable. The reason is obvious: we sort all rows, but keep only one of them . There are more efficient ways to achieve the goal. Learn more about Avoid Using Random Functions for Sorting . Use UNION ALL instead of UNION \u00b6 When a SQL statement use UNION to combine two result sets, the UNION operator will eliminate duplicates in the combined result set, which is implemented internally in the database through sorting or hashing, both of which require significant computing resources. If it can be logically guaranteed that there are no duplicate data in the two result sets, using UNION ALL instead of UNION can significantly improve performance. Limit Nesting Level of Subqueries \u00b6 Nesting subqueries make SQL complex, and too complex SQL can make the database optimizer take a long time to generate execution plans and generate poorly performing execution plans. Therefore, PawSQL detects whether the nesting level of subqueries exceeds a certain threshold and issues a warning. In PawSQL, the default value of this threshold is 2, and users can modify it when creating optimization tasks. Limit Number of Joins \u00b6 In query execution planning, the order and method of table joins are two of the main parts for the database optimizer. Increasing the number of table joins will exponentially increase the search space for the database optimizer to find the optimal execution plan, leading to longer time to generate the execution plan, and a higher chance of generating execution plans with poor performance. Therefore, PawSQL checks whether the number of table joins in the query exceeds a certain threshold and reminds the user of possible risks. In PawSQL, the default value of the threshold is 5. Implicit Type Conversion Disables Index Usage \u00b6 When the data types in the condition expression are different, some implicit data type conversions will be performed during the query execution process. Sometimes type conversion is applied to constants in the condition, and sometimes it is applied to columns in the condition. When type conversion is applied to columns, indexes won't be used, which may cause serious performance problems. For example, in the following SQL: select count(*) from ORDERS where O_ORDERDATE = current_date(); If the data type of the O_ORDERDATE column is CHAR(16) , the index on O_ORDERDATE will not be used, resulting in a full table scan. There are usually two solutions: one is to use ALTER TABLE to change the data type of O_ORDERDATE , and the other is to force current_date to be converted to the CHAR type (PawSQL provides this rewrite suggestion). select count(*) ORDERS where ORDERS.O_ORDERDATE = cast(current_date() as CHAR(16)); Learn more about Implicit Type Conversion Disables Index Usage . Type Mismatch in Join Conditions \u00b6 When the data types in the condition expression are different, some implicit data type conversions will be performed during the query execution. When type conversion is applied to columns, indexes cannot be used during query execution, which may cause serious performance problems. PawSQL will check for such syntax and issue a warning. Avoid FOR UPDATE in SELECT \u00b6 Adding FOR UPDATE in SELECT statements will lock tables or data rows, affect query concurrency, and cause blocking and performance degradation, so it should be used with caution. PawSQL will check for such syntax and issue a warning. Avoid using LIMIT in UPDATE \u00b6 Using LIMIT in UPDATE statements may cause unpredictable updated data and should be used with caution. PawSQL will check for such syntax and issue a warning. Avoid using LIMIT in SELECT w/o ORDER BY \u00b6 Using LIMIT in a SELECT statement without an ORDER BY clause can cause inconsistent results upon each execution. PawSQL detects this type of usage and issues a warning. Avoid using LIMIT in UPDELETE w/o ORDER BY \u00b6 Using LIMIT in UPDATE or DELETE statements without ORDER BY will cause inconsistent results for different execution. PawSQL will check for such syntax and issue a warning. PostgreSQL/Opengauss does not support the ORDER BY clause in UPDATE or DELETE statements. Avoid SELECT w/o Conditions and Grouping \u00b6 Queries without conditions and grouping syntax will cause full table scans and huge result sets, which will consume large portion of system resources. PawSQL will check for such syntax and issue a warning. Avoid UPDELETE w/o conditions \u00b6 UPDATE or DELETE statements without query conditions or with conditions that always evaluate to true can update or delete all data records, which is a very dangerous operation. PawSQL will check for such syntax and issue a warning. Limit Number of Values in INSERT \u00b6 Bulk insertion of values can effectively improve the efficiency of data insertion, as shown below: insert into customer(c_custkey, lastname, firstName) values(1, 'Dan', 'Mike'),(2, 'Chaw', 'Tomas'),(3, 'Wang', 'Nancy'); However, if the amount of data being inserted is too large and exceeds the database limit (MySQL: max_allowed_packet ), the database server will report an error. In PawSQL, this syntax will be checked, and an alert will be issued for SQL that exceeds the threshold (default is 500). No Column Names in INSERT \u00b6 INSERT statements should specify column names to reduce the possibility of misalignment between inserted values and the columns of the target table. insert into customer value(1, 'Dan', 'Mike'); The following syntax can reduce the possibility of misalignment between inserted values and the columns of the target table, and making the code easier to maintain. insert into customer(c_custkey, lastname, firstName) value(1, 'Dan', 'Mike'); Limit OFFSET values \u00b6 In SQL queries, the LIMIT clause is used to limit the number of query results, while the OFFSET clause is used to specify which row to start returning data from in the query result set. When the OFFSET value is large, the query engine must scan more and more data to find the data rows after the offset. In the case of a large data set, this can cause the query to become very slow and may consume a lot of system resources. Avoid LIKE Condition starts with % \u00b6 In SQL queries, the LIKE operator is used to match strings. If the pattern string starts with % (for example, LIKE '%ABC' ), the database optimizer cannot use an index to filter data, which can easily lead to a full table scan. In the absence of other filtering conditions, this may have a significant impact on query performance and efficiency. Therefore, you should try to avoid LIKE conditions that start with % . If you must use it, consider creating a full-text index to improve query performance. SELECT w/ OR Conditions Rewrite \u00b6 If a query statement uses OR conditions, the database optimizer may not be able to use an index to complete the query. For example: select * from lineitem where l_shipdate = date '2010-12-01' or l_partkey < 100 If both fields have indexes, you can rewrite the query statement as a UNION query to use the index to improve query performance: select * from lineitem where l_shipdate = date '2010-12-01' union select * from lineitem where l_partkey<100 If the database supports INDEX MERGING (please refer to How to create efficient indexes ), you can also adjust the database-related parameters to enable the INDEX MERGING optimization strategy to improve database performance. Learn more about SELECT with OR Conditions Rewrite . UPDELETE w/ OR Conditions Rewrite \u00b6 If an UPDATE or DELETE statement uses an OR condition, the database optimizer may not be able to take advantage of indexes. delete from lineitem where l_shipdate = date '2010-12-01' or l_partkey < 100 If there are indexes on both l_shipdate and l_shipdate , about statement can be rewritten into multiple DELETE statements, using indexes to improve query performance. delete from lineitem where l_shipdate = date '2010-12-01' ; delete from lineitem where l_partkey < 100 ; DELETE w/o Condition \u00b6 DELETE statements without a query condition or with a condition that is always evaluated to true will delete all data in the table. DELETE statements require writing logs for transaction function and data synchronization. For large tables, this may cause database locking and transaction blocking, as well as consuming a large amount of log space. If the data in the table is confirmed to be no longer needed, you can use TRUNCATE table instead of the DELETE statement. TRUNCATE is faster than DELETE because it does not record each deleted row, but directly clears the table and releases space. delete from lineitem to truncate lineitem Calculation Disables Index Usage \u00b6 Calculations on indexed columns will disable index usage, which can lead to full table scans and serious performance problems. Therefore, calculations on indexed columns should be converted to the constant side as much as possible. For the following SQL as an example. select * from tpch . orders where adddate ( o_orderdate , INTERVAL 31 DAY ) = date '2019-10-10' The adddate function will disable the usage of the index on o_orderdate . Query can be rewritten to the following equivalent SQL and is able to use the index to improve query efficiency. select * from tpch . orders where o_orderdate = subdate ( date '2019-10-10' , INTERVAL 31 DAY ); PawSQL can help convert a large number of functions and operations related to + , - , * , / operators. Learn more about Calculation Disables Index Usage . IN Subquery Optimization \u00b6 An IN subquery is a type of subquery that takes the following form. An IN subquery can be rewritten as an equivalent correlated EXISTS subquery or inner join, which can create a extra filtering condition. If the filtering condition has an appropriate index or is recommended by the PawSQL index recommendation engine, better performance can be achieved. ( expr1 , expr2 ...) [ NOT ] IN ( SELECT expr3 , expr4 , ...) IN Subquery to EXISTS conversion For example, the following IN subquery is used to retrieve user information for users who have placed orders within the past year: select * from customer where c_custkey in ( select o_custkey from orders where O_ORDERDATE >= current_date - interval 1 year ) It can be rewritten as an EXISTS subquery, which creates a extra filtering condition ( c_custkey = o_custkey ): select * from customer where exists ( select * from orders where c_custkey = o_custkey and O_ORDERDATE >= current_date - interval 1 year ) IN Subquery to INNER join conversion If the query result of a subquery is distinct, then the IN subquery can be rewritten as a join between two tables. This allows the database optimizer to plan a better table join sequence and also enables PawSQL to recommend better optimization methods. For example, consider the following SQL query where c_custkey is the primary key of the customer table: SELECT * FROM orders WHERE o_custkey IN ( SELECT c_custkey FROM customer ); Here, orders and customer are two related tables, where c_custkey is the primary key of the customer table and o_custkey is the foreign key in the orders table that relates to the customer table. If the query result of the subquery is distinct, we can rewrite the query as a JOIN query, as shown below: SELECT * FROM orders , customer where orders . o_custkey = customer . c_custkey ; By rewriting the IN subquery as a JOIN query, the database optimizer can plan a better table join sequence and choose a better execution plan while executing the query. In addition, such a query is also easier to understand and maintain. Learn more about IN Subquery Optimization About PawSQL \u00b6 PawSQL is dedicated to automatic and intelligent database performance optimization. The products provided by PawSQL include: PawSQL Cloud , an online automated SQL optimization tool that supports SQL auditing, intelligent query rewriting, cost-based index recommendations, suitable for database administrators and data application developers. PawSQL Advisor , an IntelliJ plugin that is suitable for data application developers and can be installed via the IDEA/DataGrip marketplace by searching for \"PawSQL Advisor\" by name. PawSQL Engine, which is the backend optimization engine of the PawSQL series of products, can be installed and deployed independently, and provides SQL optimization services through http/json interfaces. PawSQL Engine is provided for deployment and installation as a docker image. Contact Us \u00b6 Email: service@pawsql.com Twitter: https://twitter.com/pawsql","title":"Optimization Rules"},{"location":"pawreference/rewrite-rules/#optimization-overview","text":"Copyright \u00a9 2022 PawSQL","title":"Optimization Overview"},{"location":"pawreference/rewrite-rules/#join-elimination","text":"Join Elimination is an optimization technique that simplifies SQL and improves query performance by removing joins from the query that do not affect the final result. Typically, this optimization can be applied when a query includes a primary-foreign key join and only references the primary key column of the parent table. Consider the following example: select o . * from orders o inner join customer c on c . c_custkey = o . o_custkey In this query, the orders table is joined with the customer table on the primary-foreign key relationship, and c_custkey is the primary key. Therefore, the customer table can be eliminated from the query, and the rewritten SQL would be: select * from orders where o_custkey Learn more about Join Elimination ;","title":"Join Elimination"},{"location":"pawreference/rewrite-rules/#outer2inner-join-conversion","text":"Outer join optimization refers to the conversion of an outer join that satisfies certain conditions (the outer table has a NULL rejection condition) into an inner join, allowing the database optimizer to choose a more optimal execution plan and improve the performance of SQL queries. Consider the following example: select c_custkey from orders left join customer on c_custkey = o_custkey where C_NATIONKEY < 20 C_NATIONKEY < 20 is a NULL rejection condition on the customer table, so the left outer join can be rewritten as an inner join: select c_custkey from orders inner join customer on c_custkey = o_custkey where C_NATIONKEY < 20 Learn more about Outer2Inner Join Conversion .","title":"Outer2Inner Join Conversion"},{"location":"pawreference/rewrite-rules/#sat-tc-rewrite","text":"SAT-TC (SATisfiability-Transitive Closure) rewrite optimization refers to analyzing a set of related query conditions to discover contradictory, to simplify, or to infer more conditions, helping the database optimizer choose a better execution plan to improve SQL performance. Consider the following example: select c . c_name FROM customer c where c . c_name = 'John' and c . c_name = 'Jessey' Because the conditions are contradictory, the rewritten SQL is: select c . c_name from customer as c where 1 = 0 Learn more about SAT-TC Rewrite .","title":"SAT-TC Rewrite"},{"location":"pawreference/rewrite-rules/#query-folding","text":"Query folding refers to extending views, CTEs, or DT subqueries and merging them with the query statement that references them to reduce the serialization of intermediate result sets or trigger better optimization techniques for table joins. Consider the following example: SELECT * FROM ( SELECT c_custkey , c_name FROM customer ) AS derived_t1 ; The rewritten SQL is: SELECT c_custkey , c_name FROM customer Learn more about Query Folding .","title":"Query Folding"},{"location":"pawreference/rewrite-rules/#projection-pushdown","text":"Projection pushdown removes useless columns (not used in the outer query) from DT subqueries to reduce the cost of I/O and network, while increasing the chances of adopting index-only optimization strategy to improve query performance. Consider the following example: SELECT count ( 1 ) FROM ( SELECT c_custkey , avg ( age ) FROM customer group by c_custkey ) AS derived_t1 ; The rewritten SQL is: SELECT count ( 1 ) FROM ( SELECT 1 FROM customer group by c_custkey ) AS derived_t1 ; Learn more about Projection Pushdown .","title":"Projection Pushdown"},{"location":"pawreference/rewrite-rules/#nullable-in-subqueries-rewrite","text":"For the following SQL query which intends to find out customers without orders: select * from customer where c_custkey not in ( select o_custkey from orders ) If the result set of the subquery contains NULL rows, this SQL query will always return an empty result. The correct way is to add a is not null condition to the subquery, like this: select * from customer where c_custkey not in ( select o_custkey from orders where o_custkey is not null ) Learn more about Nullable IN Subqueries Rewrite .","title":"Nullable IN-Subqueries Rewrite"},{"location":"pawreference/rewrite-rules/#having-condition-pushdown","text":"Logically, conditions on the HAVING clause are executed after GROUP BY , and the conditions on the WHERE clause can be executed during table access (index access) or after table access and before GROUP BY , which are less costly. Consider the following example: select c_custkey, count(*) from customer group by c_custkey having c_custkey < 100 The rewritten SQL is: select c_custkey , count ( * ) from customer where c_custkey < 100 group by c_custkey Learn more about HAVING Condition Pushdown .","title":"HAVING Condition Pushdown"},{"location":"pawreference/rewrite-rules/#all-qualified-subqueries-rewrite","text":"Assuming the following SQL is used to obtain registered users after the order system is closed: select * from customer where c_regdate > all ( select o_orderdate from orders ) If there is a NULL value in the result of the subquery, this SQL always returns empty result. The correct method is to add a is not null condition in the subquery or rewrite to the max/min subquery. select * from customer where c_regdate > ( select max ( o_custkey ) from orders ) PawSQL uses the second. Learn more about ALL Qualified Subqueries Optimization .","title":"ALL Qualified Subqueries Rewrite"},{"location":"pawreference/rewrite-rules/#maxmin-subquery-rewrite","text":"For subqueries that use MAX/MIN , such as select * from customer where c_custkey = ( select max ( o_custkey ) from orders ) can be rewritten in the following way to avoid aggregation and take advantage of the index's ordering: select * from customer where c_custkey = ( select o_custkey from orders order by o_custkey desc null last limit 1 ) Learn more about MAX/MIN Subquery Rewrite .","title":"MAX/MIN Subquery Rewrite"},{"location":"pawreference/rewrite-rules/#count-ssq-rewrite","text":"For the following scalar subquery(SSQ), select * from customer where (select count(*) from orders where c_custkey=o_custkey) > 0 it can be rewritten to following EXISTS query which avoids the aggregation: select * from customer where exists ( select 1 from orders where c_custkey = o_custkey ) Learn more about COUNT SSQ Optimization .","title":"COUNT SSQ Rewrite"},{"location":"pawreference/rewrite-rules/#avoid-using-null","text":"=null or case when null cannot judge whether the expression is null. To determine whether the expression is null, use is null . The appearance of =null or case when null in SQL is most likely an error made by developers because they are always judged as false, equivalent to 1=0. Therefore, PawSQL checks and reminds developers of this type of writing, and performs rewriting. For example, the following SQL, select case c_phone when null then 0 else 1 end from customer ; will be rewritten by PawSQL as select case when c_phone is null then 0 else 1 end from customer ; Learn more about Avoid using =NULL .","title":"Avoid using =NULL"},{"location":"pawreference/rewrite-rules/#avoid-using-select","text":"The disadvantages of using SELECT * in queries are as follows: If SELECT * contains unused large fields, especially TEXT / CLOB type fields, it is easy to cause unnecessary disk IO and network overhead. Using SELECT * increases the effort of maintenance, such as inconsistent with the resultMap configuration when adding or deleting fields, and incorrect field mapping when using insert into select * . The database optimizer cannot take advantage of the coverage index. PawSQL index recommendation cannot recommend coverage index. Learn more about Avoid Using SELECT * .","title":"Avoid Using SELECT *"},{"location":"pawreference/rewrite-rules/#avoid-using-random-functions-for-sorting","text":"MySQL's rand function or PostgreSQL's random function returns a random floating-point number between 0 and 1.0. Sometimes we use the following query statement to obtain a random sample of the data set. select * from orders order by rand () limit 1 ; If the customer table has fewer than 10,000 rows, this method works well. But when you have 1,000,000 rows, the cost of sorting becomes unacceptable. The reason is obvious: we sort all rows, but keep only one of them . There are more efficient ways to achieve the goal. Learn more about Avoid Using Random Functions for Sorting .","title":"Avoid Using Random Functions for Sorting"},{"location":"pawreference/rewrite-rules/#use-union-all-instead-of-union","text":"When a SQL statement use UNION to combine two result sets, the UNION operator will eliminate duplicates in the combined result set, which is implemented internally in the database through sorting or hashing, both of which require significant computing resources. If it can be logically guaranteed that there are no duplicate data in the two result sets, using UNION ALL instead of UNION can significantly improve performance.","title":"Use UNION ALL instead of UNION"},{"location":"pawreference/rewrite-rules/#limit-nesting-level-of-subqueries","text":"Nesting subqueries make SQL complex, and too complex SQL can make the database optimizer take a long time to generate execution plans and generate poorly performing execution plans. Therefore, PawSQL detects whether the nesting level of subqueries exceeds a certain threshold and issues a warning. In PawSQL, the default value of this threshold is 2, and users can modify it when creating optimization tasks.","title":"Limit Nesting Level of Subqueries"},{"location":"pawreference/rewrite-rules/#limit-number-of-joins","text":"In query execution planning, the order and method of table joins are two of the main parts for the database optimizer. Increasing the number of table joins will exponentially increase the search space for the database optimizer to find the optimal execution plan, leading to longer time to generate the execution plan, and a higher chance of generating execution plans with poor performance. Therefore, PawSQL checks whether the number of table joins in the query exceeds a certain threshold and reminds the user of possible risks. In PawSQL, the default value of the threshold is 5.","title":"Limit Number of Joins"},{"location":"pawreference/rewrite-rules/#implicit-type-conversion-disables-index-usage","text":"When the data types in the condition expression are different, some implicit data type conversions will be performed during the query execution process. Sometimes type conversion is applied to constants in the condition, and sometimes it is applied to columns in the condition. When type conversion is applied to columns, indexes won't be used, which may cause serious performance problems. For example, in the following SQL: select count(*) from ORDERS where O_ORDERDATE = current_date(); If the data type of the O_ORDERDATE column is CHAR(16) , the index on O_ORDERDATE will not be used, resulting in a full table scan. There are usually two solutions: one is to use ALTER TABLE to change the data type of O_ORDERDATE , and the other is to force current_date to be converted to the CHAR type (PawSQL provides this rewrite suggestion). select count(*) ORDERS where ORDERS.O_ORDERDATE = cast(current_date() as CHAR(16)); Learn more about Implicit Type Conversion Disables Index Usage .","title":"Implicit Type Conversion Disables Index Usage"},{"location":"pawreference/rewrite-rules/#type-mismatch-in-join-conditions","text":"When the data types in the condition expression are different, some implicit data type conversions will be performed during the query execution. When type conversion is applied to columns, indexes cannot be used during query execution, which may cause serious performance problems. PawSQL will check for such syntax and issue a warning.","title":"Type Mismatch in Join Conditions"},{"location":"pawreference/rewrite-rules/#avoid-for-update-in-select","text":"Adding FOR UPDATE in SELECT statements will lock tables or data rows, affect query concurrency, and cause blocking and performance degradation, so it should be used with caution. PawSQL will check for such syntax and issue a warning.","title":"Avoid FOR UPDATE in SELECT"},{"location":"pawreference/rewrite-rules/#avoid-using-limit-in-update","text":"Using LIMIT in UPDATE statements may cause unpredictable updated data and should be used with caution. PawSQL will check for such syntax and issue a warning.","title":"Avoid using LIMIT in UPDATE"},{"location":"pawreference/rewrite-rules/#avoid-using-limit-in-select-wo-order-by","text":"Using LIMIT in a SELECT statement without an ORDER BY clause can cause inconsistent results upon each execution. PawSQL detects this type of usage and issues a warning.","title":"Avoid using LIMIT in SELECT w/o ORDER BY"},{"location":"pawreference/rewrite-rules/#avoid-using-limit-in-updelete-wo-order-by","text":"Using LIMIT in UPDATE or DELETE statements without ORDER BY will cause inconsistent results for different execution. PawSQL will check for such syntax and issue a warning. PostgreSQL/Opengauss does not support the ORDER BY clause in UPDATE or DELETE statements.","title":"Avoid using LIMIT in UPDELETE w/o ORDER BY"},{"location":"pawreference/rewrite-rules/#avoid-select-wo-conditions-and-grouping","text":"Queries without conditions and grouping syntax will cause full table scans and huge result sets, which will consume large portion of system resources. PawSQL will check for such syntax and issue a warning.","title":"Avoid SELECT w/o Conditions and Grouping"},{"location":"pawreference/rewrite-rules/#avoid-updelete-wo-conditions","text":"UPDATE or DELETE statements without query conditions or with conditions that always evaluate to true can update or delete all data records, which is a very dangerous operation. PawSQL will check for such syntax and issue a warning.","title":"Avoid UPDELETE w/o conditions"},{"location":"pawreference/rewrite-rules/#limit-number-of-values-in-insert","text":"Bulk insertion of values can effectively improve the efficiency of data insertion, as shown below: insert into customer(c_custkey, lastname, firstName) values(1, 'Dan', 'Mike'),(2, 'Chaw', 'Tomas'),(3, 'Wang', 'Nancy'); However, if the amount of data being inserted is too large and exceeds the database limit (MySQL: max_allowed_packet ), the database server will report an error. In PawSQL, this syntax will be checked, and an alert will be issued for SQL that exceeds the threshold (default is 500).","title":"Limit Number of Values in INSERT"},{"location":"pawreference/rewrite-rules/#no-column-names-in-insert","text":"INSERT statements should specify column names to reduce the possibility of misalignment between inserted values and the columns of the target table. insert into customer value(1, 'Dan', 'Mike'); The following syntax can reduce the possibility of misalignment between inserted values and the columns of the target table, and making the code easier to maintain. insert into customer(c_custkey, lastname, firstName) value(1, 'Dan', 'Mike');","title":"No Column Names in INSERT"},{"location":"pawreference/rewrite-rules/#limit-offset-values","text":"In SQL queries, the LIMIT clause is used to limit the number of query results, while the OFFSET clause is used to specify which row to start returning data from in the query result set. When the OFFSET value is large, the query engine must scan more and more data to find the data rows after the offset. In the case of a large data set, this can cause the query to become very slow and may consume a lot of system resources.","title":"Limit OFFSET values"},{"location":"pawreference/rewrite-rules/#avoid-like-condition-starts-with","text":"In SQL queries, the LIKE operator is used to match strings. If the pattern string starts with % (for example, LIKE '%ABC' ), the database optimizer cannot use an index to filter data, which can easily lead to a full table scan. In the absence of other filtering conditions, this may have a significant impact on query performance and efficiency. Therefore, you should try to avoid LIKE conditions that start with % . If you must use it, consider creating a full-text index to improve query performance.","title":"Avoid LIKE Condition starts with %"},{"location":"pawreference/rewrite-rules/#select-w-or-conditions-rewrite","text":"If a query statement uses OR conditions, the database optimizer may not be able to use an index to complete the query. For example: select * from lineitem where l_shipdate = date '2010-12-01' or l_partkey < 100 If both fields have indexes, you can rewrite the query statement as a UNION query to use the index to improve query performance: select * from lineitem where l_shipdate = date '2010-12-01' union select * from lineitem where l_partkey<100 If the database supports INDEX MERGING (please refer to How to create efficient indexes ), you can also adjust the database-related parameters to enable the INDEX MERGING optimization strategy to improve database performance. Learn more about SELECT with OR Conditions Rewrite .","title":"SELECT w/ OR Conditions Rewrite"},{"location":"pawreference/rewrite-rules/#updelete-wor-conditions-rewrite","text":"If an UPDATE or DELETE statement uses an OR condition, the database optimizer may not be able to take advantage of indexes. delete from lineitem where l_shipdate = date '2010-12-01' or l_partkey < 100 If there are indexes on both l_shipdate and l_shipdate , about statement can be rewritten into multiple DELETE statements, using indexes to improve query performance. delete from lineitem where l_shipdate = date '2010-12-01' ; delete from lineitem where l_partkey < 100 ;","title":"UPDELETE w/OR Conditions Rewrite"},{"location":"pawreference/rewrite-rules/#delete-wo-condition","text":"DELETE statements without a query condition or with a condition that is always evaluated to true will delete all data in the table. DELETE statements require writing logs for transaction function and data synchronization. For large tables, this may cause database locking and transaction blocking, as well as consuming a large amount of log space. If the data in the table is confirmed to be no longer needed, you can use TRUNCATE table instead of the DELETE statement. TRUNCATE is faster than DELETE because it does not record each deleted row, but directly clears the table and releases space. delete from lineitem to truncate lineitem","title":"DELETE w/o Condition"},{"location":"pawreference/rewrite-rules/#calculation-disables-index-usage","text":"Calculations on indexed columns will disable index usage, which can lead to full table scans and serious performance problems. Therefore, calculations on indexed columns should be converted to the constant side as much as possible. For the following SQL as an example. select * from tpch . orders where adddate ( o_orderdate , INTERVAL 31 DAY ) = date '2019-10-10' The adddate function will disable the usage of the index on o_orderdate . Query can be rewritten to the following equivalent SQL and is able to use the index to improve query efficiency. select * from tpch . orders where o_orderdate = subdate ( date '2019-10-10' , INTERVAL 31 DAY ); PawSQL can help convert a large number of functions and operations related to + , - , * , / operators. Learn more about Calculation Disables Index Usage .","title":"Calculation Disables Index Usage"},{"location":"pawreference/rewrite-rules/#in-subquery-optimization","text":"An IN subquery is a type of subquery that takes the following form. An IN subquery can be rewritten as an equivalent correlated EXISTS subquery or inner join, which can create a extra filtering condition. If the filtering condition has an appropriate index or is recommended by the PawSQL index recommendation engine, better performance can be achieved. ( expr1 , expr2 ...) [ NOT ] IN ( SELECT expr3 , expr4 , ...) IN Subquery to EXISTS conversion For example, the following IN subquery is used to retrieve user information for users who have placed orders within the past year: select * from customer where c_custkey in ( select o_custkey from orders where O_ORDERDATE >= current_date - interval 1 year ) It can be rewritten as an EXISTS subquery, which creates a extra filtering condition ( c_custkey = o_custkey ): select * from customer where exists ( select * from orders where c_custkey = o_custkey and O_ORDERDATE >= current_date - interval 1 year ) IN Subquery to INNER join conversion If the query result of a subquery is distinct, then the IN subquery can be rewritten as a join between two tables. This allows the database optimizer to plan a better table join sequence and also enables PawSQL to recommend better optimization methods. For example, consider the following SQL query where c_custkey is the primary key of the customer table: SELECT * FROM orders WHERE o_custkey IN ( SELECT c_custkey FROM customer ); Here, orders and customer are two related tables, where c_custkey is the primary key of the customer table and o_custkey is the foreign key in the orders table that relates to the customer table. If the query result of the subquery is distinct, we can rewrite the query as a JOIN query, as shown below: SELECT * FROM orders , customer where orders . o_custkey = customer . c_custkey ; By rewriting the IN subquery as a JOIN query, the database optimizer can plan a better table join sequence and choose a better execution plan while executing the query. In addition, such a query is also easier to understand and maintain. Learn more about IN Subquery Optimization","title":"IN Subquery Optimization"},{"location":"pawreference/rewrite-rules/#about-pawsql","text":"PawSQL is dedicated to automatic and intelligent database performance optimization. The products provided by PawSQL include: PawSQL Cloud , an online automated SQL optimization tool that supports SQL auditing, intelligent query rewriting, cost-based index recommendations, suitable for database administrators and data application developers. PawSQL Advisor , an IntelliJ plugin that is suitable for data application developers and can be installed via the IDEA/DataGrip marketplace by searching for \"PawSQL Advisor\" by name. PawSQL Engine, which is the backend optimization engine of the PawSQL series of products, can be installed and deployed independently, and provides SQL optimization services through http/json interfaces. PawSQL Engine is provided for deployment and installation as a docker image.","title":"About PawSQL"},{"location":"pawreference/rewrite-rules/#contact-us","text":"Email: service@pawsql.com Twitter: https://twitter.com/pawsql","title":"Contact Us"},{"location":"pawreference/sat-tc/","text":"SAT-TC Rewrite \u00b6 Channel of advanced SQL tuning Definition \u00b6 SAT-TC(Satisfiability-Transitive Closure) rewrite rule analyzes a set of predicates and try to determine if 1) there is a contradiction (e.g., c_custkey=1 AND c_custkey=0 ), or 2) new predicates can be inferred from the set (e.g., c_custkey=1 AND c_custkey=o_custkey implies o_custkey=1 . 3) predicates can simplified (e.g. c_custkey <> c_custkey or c_name = 'b' can be simplified to c_name = 'b' ) Benefit \u00b6 Save unnecessary predicate evaluations (for database optimizer ) Provide additional access path to the Join Planner (for database optimizer ) Enable other rewrite rules (for both database optimizer and PawSQL engine ) Provide more predicates for index recommendation(for PawSQL ); Examples \u00b6 SAT Example : original query select c.c_name FROM customer c where c.c_name = 'John' and c.c_name = 'Jessey' rewritten query select c.c_name from customer as c where 1 = 0 TC Example original query select o_custkey as cust_no, l_extendedprice * (1 - l_discount) from orders, lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234'; rewritten query select o_custkey as cust_no, l_extendedprice * (1 - l_discount) from orders, lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234' and o_orderkey = 'ORD1234';","title":"SAT-TC Rewrite"},{"location":"pawreference/sat-tc/#sat-tc-rewrite","text":"Channel of advanced SQL tuning","title":"SAT-TC Rewrite"},{"location":"pawreference/sat-tc/#definition","text":"SAT-TC(Satisfiability-Transitive Closure) rewrite rule analyzes a set of predicates and try to determine if 1) there is a contradiction (e.g., c_custkey=1 AND c_custkey=0 ), or 2) new predicates can be inferred from the set (e.g., c_custkey=1 AND c_custkey=o_custkey implies o_custkey=1 . 3) predicates can simplified (e.g. c_custkey <> c_custkey or c_name = 'b' can be simplified to c_name = 'b' )","title":"Definition"},{"location":"pawreference/sat-tc/#benefit","text":"Save unnecessary predicate evaluations (for database optimizer ) Provide additional access path to the Join Planner (for database optimizer ) Enable other rewrite rules (for both database optimizer and PawSQL engine ) Provide more predicates for index recommendation(for PawSQL );","title":"Benefit"},{"location":"pawreference/sat-tc/#examples","text":"SAT Example : original query select c.c_name FROM customer c where c.c_name = 'John' and c.c_name = 'Jessey' rewritten query select c.c_name from customer as c where 1 = 0 TC Example original query select o_custkey as cust_no, l_extendedprice * (1 - l_discount) from orders, lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234'; rewritten query select o_custkey as cust_no, l_extendedprice * (1 - l_discount) from orders, lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234' and o_orderkey = 'ORD1234';","title":"Examples"},{"location":"pawreference/sql-syntax/","text":"Index Advisor Engine \u00b6 Indexes serve the following three purposes from the performance perspective: Quickly locate data recording (equivalent conditions, range conditions); Avoid sorting (order by/group by/distinct/union/sort merge join); Avoid probing data from the heap table, by accessing only the index file. We use TPCH schema to demonstrate the capability of Paw Index Advisor. Sample SQLs with primary syntax are listed below, with one or two indice recommended for each SQL. Single Table Queries \u00b6 1. Equal conditions \u00b6 -- equal select * from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE ); select * from lineitem where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' , '1' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode <=> '0' ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipdate = ( select max ( l_shipdate ) from lineitem ); CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); 2.Range Conditions \u00b6 -- range select * from lineitem where l_shipdate >= date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0156881833 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate between date '2010-12-01' and date '2020-12-01' ; CREATE INDEX SQLLAB_IDX1241878058 ON LINEITEM ( L_SHIPDATE ) \uff1b select * from customer where c_phone like \"139%\" ; CREATE INDEX SQLLAB_IDX0326568991 ON CUSTOMER ( C_PHONE ); 3.Grouping and Ordering \u00b6 -- grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate ; CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE \uff0c L_QUANTITY ); -- index only -- ordering select * from lineitem order by l_shipdate limit 10 ; CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE ); 4.Combination of syntax \u00b6 -- equal + range select * from lineitem where l_shipdate = date '1998-12-01' and l_quantity > 100 ; CREATE INDEX SQLLAB_IDX2048143506 ON LINEITEM ( L_SHIPDATE , L_QUANTITY ); -- ordering+grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate order by l_shipdate ; CREATE INDEX SQLLAB_IDX1360881332 ON LINEITEM ( L_SHIPDATE ); -- where+group select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem where l_receiptdate = '2020-01-01' group by l_shipdate ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_RECEIPTDATE , L_SHIPDATE , l_quantity ); Table Joins \u00b6 SELECT * FROM ORDERS , LINEITEM WHERE O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX2127618499 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX0339323878 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1531629550 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1365836084 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1336974557 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS RIGHT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1002609246 ON ORDERS ( O_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY WHERE l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0711368375 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE ); Subqueries \u00b6 -- subquery1 select * from supplier ,( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) revenue where s_suppkey = revenue . l_suppkey ; CREATE INDEX SQLLAB_IDX0151075817 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1968327707 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE ); -- subquery2 select * from supplier where s_suppkey = ( select l_suppkey from lineitem order by l_suppkey desc limit 1 ); CREATE INDEX SQLLAB_IDX0664775210 ON SUPPLIER ( S_SUPPKEY ); -- subquery3 with revenue as ( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) select * from supplier , revenue where s_suppkey = l_suppkey ; CREATE INDEX SQLLAB_IDX0343576594 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1518532301 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE ); Query Rewrite \u00b6 1.Transitive Closure \u00b6 -- example 1 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234' ; CREATE INDEX SQLLAB_IDX0837835805 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1989932894 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 2 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey > 'ORD1234' ; CREATE INDEX SQLLAB_IDX1000938250 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1358517686 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 3 select c_custkey , c_name , sum ( l_extendedprice * ( 1 - l_discount )) as revenue from customer , orders , lineitem where c_custkey = o_orderkey and l_orderkey = o_orderkey and l_orderkey = 'ORD1234' group by c_custkey , c_name ; CREATE INDEX SQLLAB_IDX1161414921 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1584481406 ON CUSTOMER ( C_CUSTKEY , C_NAME ); CREATE INDEX SQLLAB_IDX0637857516 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); 2.Ordinal \u00b6 -- orderby ordinal select * from lineitem order by l_shipdate limit 10 CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE ); sql -- groupby ordinal select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by 1 CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE , L_QUANTITY ); Update/Delete/Insert/Merge \u00b6 delete from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); update lineitem set l_shipmode = '' where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); insert into lineitem select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); replace into lineitem select * where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE );","title":"Index Advisor Engine"},{"location":"pawreference/sql-syntax/#index-advisor-engine","text":"Indexes serve the following three purposes from the performance perspective: Quickly locate data recording (equivalent conditions, range conditions); Avoid sorting (order by/group by/distinct/union/sort merge join); Avoid probing data from the heap table, by accessing only the index file. We use TPCH schema to demonstrate the capability of Paw Index Advisor. Sample SQLs with primary syntax are listed below, with one or two indice recommended for each SQL.","title":"Index Advisor Engine"},{"location":"pawreference/sql-syntax/#single-table-queries","text":"","title":"Single Table Queries"},{"location":"pawreference/sql-syntax/#1-equal-conditions","text":"-- equal select * from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE ); select * from lineitem where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' , '1' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode <=> '0' ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipdate = ( select max ( l_shipdate ) from lineitem ); CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE );","title":"1. Equal conditions"},{"location":"pawreference/sql-syntax/#2range-conditions","text":"-- range select * from lineitem where l_shipdate >= date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0156881833 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate between date '2010-12-01' and date '2020-12-01' ; CREATE INDEX SQLLAB_IDX1241878058 ON LINEITEM ( L_SHIPDATE ) \uff1b select * from customer where c_phone like \"139%\" ; CREATE INDEX SQLLAB_IDX0326568991 ON CUSTOMER ( C_PHONE );","title":"2.Range Conditions"},{"location":"pawreference/sql-syntax/#3grouping-and-ordering","text":"-- grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate ; CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE \uff0c L_QUANTITY ); -- index only -- ordering select * from lineitem order by l_shipdate limit 10 ; CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE );","title":"3.Grouping and Ordering"},{"location":"pawreference/sql-syntax/#4combination-of-syntax","text":"-- equal + range select * from lineitem where l_shipdate = date '1998-12-01' and l_quantity > 100 ; CREATE INDEX SQLLAB_IDX2048143506 ON LINEITEM ( L_SHIPDATE , L_QUANTITY ); -- ordering+grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate order by l_shipdate ; CREATE INDEX SQLLAB_IDX1360881332 ON LINEITEM ( L_SHIPDATE ); -- where+group select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem where l_receiptdate = '2020-01-01' group by l_shipdate ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_RECEIPTDATE , L_SHIPDATE , l_quantity );","title":"4.Combination of syntax"},{"location":"pawreference/sql-syntax/#table-joins","text":"SELECT * FROM ORDERS , LINEITEM WHERE O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX2127618499 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX0339323878 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1531629550 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1365836084 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1336974557 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS RIGHT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1002609246 ON ORDERS ( O_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY WHERE l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0711368375 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE );","title":"Table Joins"},{"location":"pawreference/sql-syntax/#subqueries","text":"-- subquery1 select * from supplier ,( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) revenue where s_suppkey = revenue . l_suppkey ; CREATE INDEX SQLLAB_IDX0151075817 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1968327707 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE ); -- subquery2 select * from supplier where s_suppkey = ( select l_suppkey from lineitem order by l_suppkey desc limit 1 ); CREATE INDEX SQLLAB_IDX0664775210 ON SUPPLIER ( S_SUPPKEY ); -- subquery3 with revenue as ( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) select * from supplier , revenue where s_suppkey = l_suppkey ; CREATE INDEX SQLLAB_IDX0343576594 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1518532301 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE );","title":"Subqueries"},{"location":"pawreference/sql-syntax/#query-rewrite","text":"","title":"Query Rewrite"},{"location":"pawreference/sql-syntax/#1transitive-closure","text":"-- example 1 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234' ; CREATE INDEX SQLLAB_IDX0837835805 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1989932894 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 2 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey > 'ORD1234' ; CREATE INDEX SQLLAB_IDX1000938250 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1358517686 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 3 select c_custkey , c_name , sum ( l_extendedprice * ( 1 - l_discount )) as revenue from customer , orders , lineitem where c_custkey = o_orderkey and l_orderkey = o_orderkey and l_orderkey = 'ORD1234' group by c_custkey , c_name ; CREATE INDEX SQLLAB_IDX1161414921 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1584481406 ON CUSTOMER ( C_CUSTKEY , C_NAME ); CREATE INDEX SQLLAB_IDX0637857516 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE );","title":"1.Transitive Closure"},{"location":"pawreference/sql-syntax/#2ordinal","text":"-- orderby ordinal select * from lineitem order by l_shipdate limit 10 CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE ); sql -- groupby ordinal select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by 1 CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE , L_QUANTITY );","title":"2.Ordinal"},{"location":"pawreference/sql-syntax/#updatedeleteinsertmerge","text":"delete from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); update lineitem set l_shipmode = '' where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); insert into lineitem select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); replace into lineitem select * where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE );","title":"Update/Delete/Insert/Merge"},{"location":"pawsqladvisor/","text":"What is PawSQL Advisor \u00b6 In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Rules-based SQL auditing, targeting correctness auditing and performance optimization. Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation, based on input SQL syntax, database objects and statistics information. What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Get started \u00b6 Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization options will be presented to you. Tip: PawSQL Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get Started"},{"location":"pawsqladvisor/#what-is-pawsql-advisor","text":"In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"What is PawSQL Advisor"},{"location":"pawsqladvisor/#features","text":"Rules-based SQL auditing, targeting correctness auditing and performance optimization. Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation, based on input SQL syntax, database objects and statistics information. What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations.","title":"Features"},{"location":"pawsqladvisor/#get-started","text":"Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization options will be presented to you. Tip: PawSQL Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started"},{"location":"pawsqladvisor/change-log/","text":"Changelog \u00b6 1.0.109 _ August 13, 2022 \u00b6 Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue. 0.1.108 _ Aug 4, 2022 \u00b6 Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12. 0.1.106 _ Aug 4, 2022 \u00b6 Initial beta release.","title":"Changelog"},{"location":"pawsqladvisor/change-log/#changelog","text":"","title":"Changelog"},{"location":"pawsqladvisor/change-log/#0.1.109","text":"Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue.","title":"1.0.109 _ August 13, 2022"},{"location":"pawsqladvisor/change-log/#0.1.108","text":"Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12.","title":"0.1.108 _ Aug 4, 2022"},{"location":"pawsqladvisor/change-log/#0.1.106","text":"Initial beta release.","title":"0.1.106 _ Aug 4, 2022"},{"location":"pawsqladvisor/configuration/","text":"Configuration \u00b6 You can configure and control the execution process on the PawSQL Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation Query Type \u00b6 Specifies the type of input SQL statements. PawSQL Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, PawSQL Advisor will parse those file and permutes all possible SQL combinations. PawSQL Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog. Database Vendor \u00b6 Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested. Connection Info \u00b6 Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance. Database host \u00b6 Ip address or host name of the database server Database port \u00b6 Port of the connection to the database server User \u00b6 User name to connect to the database server Password \u00b6 The password of the user connecting to the database server DefaultDB \u00b6 The default database name when connecting to the database server Database/schema List \u00b6 For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b Deduplicate with existing indexes \u00b6 If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index. What-if analysis validation \u00b6 If this option is checked, PawSQL Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), PawSQL Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"Configuration"},{"location":"pawsqladvisor/configuration/#configuration","text":"You can configure and control the execution process on the PawSQL Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation","title":"Configuration"},{"location":"pawsqladvisor/configuration/#query-type","text":"Specifies the type of input SQL statements. PawSQL Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, PawSQL Advisor will parse those file and permutes all possible SQL combinations. PawSQL Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog.","title":"Query Type"},{"location":"pawsqladvisor/configuration/#database-vendor","text":"Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested.","title":"Database Vendor"},{"location":"pawsqladvisor/configuration/#connection-info","text":"Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance.","title":"Connection Info"},{"location":"pawsqladvisor/configuration/#database-host","text":"Ip address or host name of the database server","title":"Database host"},{"location":"pawsqladvisor/configuration/#database-port","text":"Port of the connection to the database server","title":"Database port"},{"location":"pawsqladvisor/configuration/#user","text":"User name to connect to the database server","title":"User"},{"location":"pawsqladvisor/configuration/#password","text":"The password of the user connecting to the database server","title":"Password"},{"location":"pawsqladvisor/configuration/#defaultdb","text":"The default database name when connecting to the database server","title":"DefaultDB"},{"location":"pawsqladvisor/configuration/#databaseschema-list","text":"For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b","title":"Database/schema List"},{"location":"pawsqladvisor/configuration/#deduplicate-with-existing-indexes","text":"If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index.","title":"Deduplicate with existing indexes"},{"location":"pawsqladvisor/configuration/#what-if-analysis-validation","text":"If this option is checked, PawSQL Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), PawSQL Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"What-if analysis validation"},{"location":"pawsqladvisor/eula/","text":"End-User License Agreement (EULA) of PawSQL Advisor \u00b6 This EULA agreement governs your acquisition and use of our PawSQL Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the PawSQL Advisor software. It provides a license to use the PawSQL Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the PawSQL Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the PawSQL Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant \u00b6 Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the PawSQL Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the PawSQL Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the PawSQL Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement Intellectual Property and Ownership \u00b6 Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties. Termination \u00b6 This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL. Governing Law \u00b6 This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"EULA"},{"location":"pawsqladvisor/eula/#end-user-license-agreement-eula-of-pawsql-advisor","text":"This EULA agreement governs your acquisition and use of our PawSQL Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the PawSQL Advisor software. It provides a license to use the PawSQL Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the PawSQL Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the PawSQL Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of PawSQL Advisor"},{"location":"pawsqladvisor/eula/#license-grant","text":"Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the PawSQL Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the PawSQL Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the PawSQL Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement","title":"License Grant"},{"location":"pawsqladvisor/eula/#intellectual-property-and-ownership","text":"Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"pawsqladvisor/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL.","title":"Termination"},{"location":"pawsqladvisor/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"Governing Law"},{"location":"pawsqladvisor/pawsummary/","text":"Tuning Summary \u00b6 After the tuning process is done, there is one summary file named pawSummary.sql and tuning detail files for each SQL query under a new sub-directory named tuningDetails . The outline is as follows: . \u251c\u2500 tuningDetails/ \u2502 \u2514\u2500 file1-stmt-1.txt \u2502 \u2514\u2500 file1-stmt-2.txt \u2502 \u2514\u2500 file2-stmt-1.txt \u2514\u2500 pawSummary.sql \u2514\u2500 file1.sql \u2514\u2500 file2.sql 1. Tuning Summary \u00b6 The first section briefly describes the overall of the tuning, including the number of query analyzed, the number of queries which are applied rewrite optimization to, the number of rewrite optimizations applied, the number of queries are which applied rule auditing to, the number of violations of auditing rules, the number of indexes recommended, the number of queries for which the indexes are recommended the overall performance improvement 1. Tuning Summary - There are 26 query analyzed; - There are 5 optimization rewrites for 5 queries; - There are 18 violations of optimization rule against 12 queries; - There are 33 indices recommended for 22 queries; - There is 11936685010280.29% performance improvement. 2. Optimization Rule Violations \u00b6 The second section describle what auditing rules violated or what rewrite optimization applied, and what queries are applied by those auditing rules or rewrite optimizations. 2. Optimization Rule Violations - RuleFuncWithColumnInPredicate: [22.sql-stmt1] - RuleUseEqual4Null: [R0015.sql-stmt2, R0015.sql-stmt1, R0015.sql-stmt3] - RuleNumOfJoinTables: [9.sql-stmt1, 5.sql-stmt1, 8.sql-stmt1, 2.sql-stmt1, 7.sql-stmt1] - RulePredicateLikeStartWithWildcard: [9.sql-stmt1, 13.sql-stmt1, 16.sql-stmt1, 2.sql-stmt1] - RuleUnion2UnionAll: [19.sql-stmt1] - RuleOrCond4SelectRewrite: [19.sql-stmt1] - RuleNumOfLevelOfSubQuery: [19.sql-stmt1] - RuleMaxMinAggRewrite: [2.sql-stmt1] 3. Recommended Indexes \u00b6 The third section lists all the indexes recommended by Index Advisor, if the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 . If the What-if analysis validation is checked, those indexes are verified to gain performance improvement. 3 . Recommended Indexes - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1816680539 ON TPCH . NATION ( N_NATIONKEY , N_NAME ); - CREATE INDEX PAW_IDX0156881833 ON TPCH . NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); - CREATE INDEX PAW_IDX0641962049 ON TPCH . LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0636918380 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_SUPPKEY , L_COMMITDATE ); - CREATE INDEX PAW_IDX1352680166 ON TPCH . LINEITEM ( L_SHIPMODE , L_RECEIPTDATE ); - CREATE INDEX PAW_IDX0137309144 ON TPCH . LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1021669930 ON TPCH . LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0151075817 ON TPCH . LINEITEM ( L_ORDERKEY , L_SUPPKEY ); - CREATE INDEX PAW_IDX0025038833 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_SUPPKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX1496549982 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_ORDERKEY ); - CREATE INDEX PAW_IDX0664775210 ON TPCH . LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); - CREATE INDEX PAW_IDX1318724089 ON TPCH . LINEITEM ( L_ORDERKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX2016121426 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1809130098 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); - CREATE INDEX PAW_IDX1831397382 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX1974481774 ON TPCH . CUSTOMER ( C_ACCTBAL , C_PHONE ); - CREATE INDEX PAW_IDX0499202881 ON TPCH . CUSTOMER ( C_NATIONKEY , C_CUSTKEY ); - CREATE INDEX PAW_IDX2038863975 ON TPCH . CUSTOMER ( C_CUSTKEY , C_NAME ( 16 )); - CREATE INDEX PAW_IDX2008453396 ON TPCH . CUSTOMER ( C_MKTSEGMENT , C_CUSTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); ... 4. Optimized Query List \u00b6 The fourth section lists each the SQL query together with its performance improvement, the cost before tuning, the cost after tuning, and the recommended indexes contribute to its performance improvement. Notice : If What-if analysis validation isn't checked, PawSQL Advisor will NOT get those information in this section. 4. Optimized Query List - 1.sql-stmt1, performance improves by 1041484.5070422536%[costBefore=7395.25,costAfter=0.71] -- Contributing indices:[PAW_IDX1831397382] - 10.sql-stmt1, performance improves by 1.7989040997273477E11%[costBefore=4.1374794316729E11,costAfter=230.0] -- Contributing indices:[PAW_IDX1409884827, PAW_IDX1021669930, PAW_IDX2038863975, PAW_IDX1816680539] - 11.sql-stmt1, performance improves by 2.5246486123619478E12%[costBefore=5.3143853292324E11,costAfter=21.05] -- Contributing indices:[PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX0949237515, PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX1586215289] - 12.sql-stmt1, performance improves by 436812.6436781609%[costBefore=7602.28,costAfter=1.74] -- Contributing indices:[PAW_IDX1352680166, PAW_IDX0538538531] - 13.sql-stmt1, performance improves by -99.99757285582929%[costBefore=2.5,costAfter=103001.71] -- Contributing indices:[PAW_IDX2038863975, PAW_IDX1403958132] - 14.sql-stmt1, performance improves by 3.6741429030575542E9%[costBefore=6.1284705291E8,costAfter=16.68] -- Contributing indices:[PAW_IDX0025038833, PAW_IDX0719788224] - 15.sql-stmt1, performance improves by 9308930.025445294%[costBefore=365844.88,costAfter=3.93] -- Contributing indices:[PAW_IDX1831397382, PAW_IDX1452901602] - 16.sql-stmt1, performance improves by 3093767.4732323023%[costBefore=2.04892949245268E13,costAfter=6.622550934E8] -- Contributing indices:[PAW_IDX1645425553, PAW_IDX0326568991, <AUTO_DISTINCT_KEY>] - 17.sql-stmt1, performance improves by 1.5561515563380282E9%[costBefore=5.52433838E7,costAfter=3.55] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX0664775210, PAW_IDX1809130098] - 18.sql-stmt1, performance improves by 110588.99568547281%[costBefore=1.905657921778E10,costAfter=1.721632679E7] -- Contributing indices:[PAW_IDX1403958132, <AUTO_DISTINCT_KEY>, PAW_IDX1318724089, PAW_IDX1318724089] - 19.sql-stmt1, performance improves by 2.0183056542168677E9%[costBefore=3.350387552E7,costAfter=1.66] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX1352680166] - 2.sql-stmt1, performance improves by 8.6010577952777552E16%[costBefore=1.36688870588333773E18,costAfter=1589.21] -- Contributing indices:[PAW_IDX0094600326, PAW_IDX1645425553, PAW_IDX1922219213, PAW_IDX0094600326, PAW_IDX0326568991, PAW_IDX1452901602, PAW_IDX1352808126, PAW_IDX1452901602, PAW_IDX1352808126] ... The de-duplication algorithm is adhered to left-most prefix principle. \u21a9","title":"Tuning Summary"},{"location":"pawsqladvisor/pawsummary/#tuning-summary","text":"After the tuning process is done, there is one summary file named pawSummary.sql and tuning detail files for each SQL query under a new sub-directory named tuningDetails . The outline is as follows: . \u251c\u2500 tuningDetails/ \u2502 \u2514\u2500 file1-stmt-1.txt \u2502 \u2514\u2500 file1-stmt-2.txt \u2502 \u2514\u2500 file2-stmt-1.txt \u2514\u2500 pawSummary.sql \u2514\u2500 file1.sql \u2514\u2500 file2.sql","title":"Tuning Summary"},{"location":"pawsqladvisor/pawsummary/#1-tuning-summary","text":"The first section briefly describes the overall of the tuning, including the number of query analyzed, the number of queries which are applied rewrite optimization to, the number of rewrite optimizations applied, the number of queries are which applied rule auditing to, the number of violations of auditing rules, the number of indexes recommended, the number of queries for which the indexes are recommended the overall performance improvement 1. Tuning Summary - There are 26 query analyzed; - There are 5 optimization rewrites for 5 queries; - There are 18 violations of optimization rule against 12 queries; - There are 33 indices recommended for 22 queries; - There is 11936685010280.29% performance improvement.","title":"1. Tuning Summary"},{"location":"pawsqladvisor/pawsummary/#2-optimization-rule-violations","text":"The second section describle what auditing rules violated or what rewrite optimization applied, and what queries are applied by those auditing rules or rewrite optimizations. 2. Optimization Rule Violations - RuleFuncWithColumnInPredicate: [22.sql-stmt1] - RuleUseEqual4Null: [R0015.sql-stmt2, R0015.sql-stmt1, R0015.sql-stmt3] - RuleNumOfJoinTables: [9.sql-stmt1, 5.sql-stmt1, 8.sql-stmt1, 2.sql-stmt1, 7.sql-stmt1] - RulePredicateLikeStartWithWildcard: [9.sql-stmt1, 13.sql-stmt1, 16.sql-stmt1, 2.sql-stmt1] - RuleUnion2UnionAll: [19.sql-stmt1] - RuleOrCond4SelectRewrite: [19.sql-stmt1] - RuleNumOfLevelOfSubQuery: [19.sql-stmt1] - RuleMaxMinAggRewrite: [2.sql-stmt1]","title":"2. Optimization Rule Violations"},{"location":"pawsqladvisor/pawsummary/#3-recommended-indexes","text":"The third section lists all the indexes recommended by Index Advisor, if the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 . If the What-if analysis validation is checked, those indexes are verified to gain performance improvement. 3 . Recommended Indexes - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1816680539 ON TPCH . NATION ( N_NATIONKEY , N_NAME ); - CREATE INDEX PAW_IDX0156881833 ON TPCH . NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); - CREATE INDEX PAW_IDX0641962049 ON TPCH . LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0636918380 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_SUPPKEY , L_COMMITDATE ); - CREATE INDEX PAW_IDX1352680166 ON TPCH . LINEITEM ( L_SHIPMODE , L_RECEIPTDATE ); - CREATE INDEX PAW_IDX0137309144 ON TPCH . LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1021669930 ON TPCH . LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0151075817 ON TPCH . LINEITEM ( L_ORDERKEY , L_SUPPKEY ); - CREATE INDEX PAW_IDX0025038833 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_SUPPKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX1496549982 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_ORDERKEY ); - CREATE INDEX PAW_IDX0664775210 ON TPCH . LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); - CREATE INDEX PAW_IDX1318724089 ON TPCH . LINEITEM ( L_ORDERKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX2016121426 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1809130098 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); - CREATE INDEX PAW_IDX1831397382 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX1974481774 ON TPCH . CUSTOMER ( C_ACCTBAL , C_PHONE ); - CREATE INDEX PAW_IDX0499202881 ON TPCH . CUSTOMER ( C_NATIONKEY , C_CUSTKEY ); - CREATE INDEX PAW_IDX2038863975 ON TPCH . CUSTOMER ( C_CUSTKEY , C_NAME ( 16 )); - CREATE INDEX PAW_IDX2008453396 ON TPCH . CUSTOMER ( C_MKTSEGMENT , C_CUSTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); ...","title":"3. Recommended Indexes"},{"location":"pawsqladvisor/pawsummary/#4-optimized-query-list","text":"The fourth section lists each the SQL query together with its performance improvement, the cost before tuning, the cost after tuning, and the recommended indexes contribute to its performance improvement. Notice : If What-if analysis validation isn't checked, PawSQL Advisor will NOT get those information in this section. 4. Optimized Query List - 1.sql-stmt1, performance improves by 1041484.5070422536%[costBefore=7395.25,costAfter=0.71] -- Contributing indices:[PAW_IDX1831397382] - 10.sql-stmt1, performance improves by 1.7989040997273477E11%[costBefore=4.1374794316729E11,costAfter=230.0] -- Contributing indices:[PAW_IDX1409884827, PAW_IDX1021669930, PAW_IDX2038863975, PAW_IDX1816680539] - 11.sql-stmt1, performance improves by 2.5246486123619478E12%[costBefore=5.3143853292324E11,costAfter=21.05] -- Contributing indices:[PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX0949237515, PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX1586215289] - 12.sql-stmt1, performance improves by 436812.6436781609%[costBefore=7602.28,costAfter=1.74] -- Contributing indices:[PAW_IDX1352680166, PAW_IDX0538538531] - 13.sql-stmt1, performance improves by -99.99757285582929%[costBefore=2.5,costAfter=103001.71] -- Contributing indices:[PAW_IDX2038863975, PAW_IDX1403958132] - 14.sql-stmt1, performance improves by 3.6741429030575542E9%[costBefore=6.1284705291E8,costAfter=16.68] -- Contributing indices:[PAW_IDX0025038833, PAW_IDX0719788224] - 15.sql-stmt1, performance improves by 9308930.025445294%[costBefore=365844.88,costAfter=3.93] -- Contributing indices:[PAW_IDX1831397382, PAW_IDX1452901602] - 16.sql-stmt1, performance improves by 3093767.4732323023%[costBefore=2.04892949245268E13,costAfter=6.622550934E8] -- Contributing indices:[PAW_IDX1645425553, PAW_IDX0326568991, <AUTO_DISTINCT_KEY>] - 17.sql-stmt1, performance improves by 1.5561515563380282E9%[costBefore=5.52433838E7,costAfter=3.55] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX0664775210, PAW_IDX1809130098] - 18.sql-stmt1, performance improves by 110588.99568547281%[costBefore=1.905657921778E10,costAfter=1.721632679E7] -- Contributing indices:[PAW_IDX1403958132, <AUTO_DISTINCT_KEY>, PAW_IDX1318724089, PAW_IDX1318724089] - 19.sql-stmt1, performance improves by 2.0183056542168677E9%[costBefore=3.350387552E7,costAfter=1.66] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX1352680166] - 2.sql-stmt1, performance improves by 8.6010577952777552E16%[costBefore=1.36688870588333773E18,costAfter=1589.21] -- Contributing indices:[PAW_IDX0094600326, PAW_IDX1645425553, PAW_IDX1922219213, PAW_IDX0094600326, PAW_IDX0326568991, PAW_IDX1452901602, PAW_IDX1352808126, PAW_IDX1452901602, PAW_IDX1352808126] ... The de-duplication algorithm is adhered to left-most prefix principle. \u21a9","title":"4. Optimized Query List"},{"location":"pawsqladvisor/tuningdetails/","text":"Tuning Details \u00b6 For each tuned query, there is a corresponding tuning details file produced to show you WHAT and HOW the query is tuned, HOW MUCH does its performance improve and ect. There are FIVE sections in this statement level tuning detail result file, as follows. 1. Original Query \u00b6 1 . Original Query ( formatted ) select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select min ( partsupp . ps_supplycost ) from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ))) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ; 2. Rewritten Query \u00b6 2 . Rewritten Query - Rule : RuleMaxMinAggRewrite select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select partsupp . ps_supplycost from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ) order by partsupp . ps_supplycost asc limit 1 )) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ; 3. Auditing Rule Violations \u00b6 3 . Auditing Rule Violations - Rule : RulePredicateLikeStartWithWildcard - Violation Parts : part . p_type like '%STEEL' ; - Rule : RuleNumOfJoinTables ( threshold -> 5 ) - Violation Parts : FROM TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region ; 4. Index Recommended \u00b6 Indexes recommended by Paw Advisor and contribute to this SQL query will be listed below. 4 . Index Recommended - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX1645425553 ON TPCH . PART ( P_SIZE , P_TYPE ( 16 ), P_BRAND ); - CREATE INDEX PAW_IDX1922219213 ON TPCH . PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX0326568991 ON TPCH . PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); 5. Validation Details \u00b6 5 . Validation Details 5 . 1 Performance improves by 2 . 67 E16 % - cost_before = 2 . 7375641592668303 E18 - cost_after = 10234 . 800000000001 5 . 2 Query Plan ( before ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Inner hash join ( part . P_PARTKEY = partsupp . PS_PARTKEY ), ( partsupp . PS_SUPPLYCOST = ( select # 2 )) ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Filter : (( part . P_SIZE = 30 ) and ( part . P_TYPE like '%STEEL' )) ( cost = 282 . 66 rows = 774 ) -> Table scan on part ( cost = 282 . 66 rows = 697018 ) -> Hash -> Inner hash join ( partsupp . PS_SUPPKEY = supplier . S_SUPPKEY ) ( cost = 3786224480556435 . 50 rows = 3785350948227630 ) -> Table scan on partsupp ( cost = 0 . 67 rows = 72391 ) -> Hash -> Inner hash join ( supplier . S_NATIONKEY = nation . N_NATIONKEY ) ( cost = 522968063410 . 36 rows = 522903522789 ) -> Table scan on supplier ( cost = 0 . 25 rows = 101512 ) -> Hash -> Inner hash join ( nation . N_REGIONKEY = region . R_REGIONKEY ) ( cost = 51519510 . 02 rows = 51511498 ) -> Table scan on nation ( cost = 0 . 20 rows = 72308 ) -> Hash -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 7308 . 15 rows = 7124 ) -> Table scan on region ( cost = 7308 . 15 rows = 71239 ) 5 . 3 Query Plan ( after ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1562 . 36 rows = 24 ) -> Nested loop inner join ( cost = 1553 . 82 rows = 7 ) -> Nested loop inner join ( cost = 1354 . 61 rows = 142 ) -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Filter : ( part . P_TYPE like '%STEEL' ) ( cost = 1240 . 09 rows = 142 ) -> Index lookup on part using PAW_IDX1645425553 ( P_SIZE = 30 ) ( cost = 1240 . 09 rows = 1276 ) -> Filter : (( partsupp . PS_PARTKEY = part . P_PARTKEY ) and ( partsupp . PS_SUPPLYCOST = ( select # 2 ))) ( cost = 1 . 01 rows = 0 . 05 ) -> Covering index lookup on partsupp using PAW_IDX1922219213 ( PS_SUPPLYCOST = ( select # 2 )) ( cost = 1 . 01 rows = 4 ) -> Select # 2 ( subquery in condition ; dependent ) -> Aggregate : min ( partsupp . PS_SUPPLYCOST ) ( cost = 41 . 31 rows = 1 ) -> Nested loop inner join ( cost = 38 . 82 rows = 25 ) -> Nested loop inner join ( cost = 11 . 53 rows = 25 ) -> Nested loop inner join ( cost = 2 . 84 rows = 7 ) -> Filter : ( region . R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on partsupp using PAW_IDX0326568991 ( PS_PARTKEY = part . P_PARTKEY ) ( cost = 1 . 74 rows = 7 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 )","title":"Tuning Details"},{"location":"pawsqladvisor/tuningdetails/#tuning-details","text":"For each tuned query, there is a corresponding tuning details file produced to show you WHAT and HOW the query is tuned, HOW MUCH does its performance improve and ect. There are FIVE sections in this statement level tuning detail result file, as follows.","title":"Tuning Details"},{"location":"pawsqladvisor/tuningdetails/#1-original-query","text":"1 . Original Query ( formatted ) select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select min ( partsupp . ps_supplycost ) from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ))) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ;","title":"1. Original Query"},{"location":"pawsqladvisor/tuningdetails/#2-rewritten-query","text":"2 . Rewritten Query - Rule : RuleMaxMinAggRewrite select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select partsupp . ps_supplycost from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ) order by partsupp . ps_supplycost asc limit 1 )) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ;","title":"2. Rewritten Query"},{"location":"pawsqladvisor/tuningdetails/#3-auditing-rule-violations","text":"3 . Auditing Rule Violations - Rule : RulePredicateLikeStartWithWildcard - Violation Parts : part . p_type like '%STEEL' ; - Rule : RuleNumOfJoinTables ( threshold -> 5 ) - Violation Parts : FROM TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region ;","title":"3. Auditing Rule Violations"},{"location":"pawsqladvisor/tuningdetails/#4-index-recommended","text":"Indexes recommended by Paw Advisor and contribute to this SQL query will be listed below. 4 . Index Recommended - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX1645425553 ON TPCH . PART ( P_SIZE , P_TYPE ( 16 ), P_BRAND ); - CREATE INDEX PAW_IDX1922219213 ON TPCH . PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX0326568991 ON TPCH . PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME );","title":"4. Index Recommended"},{"location":"pawsqladvisor/tuningdetails/#5-validation-details","text":"5 . Validation Details 5 . 1 Performance improves by 2 . 67 E16 % - cost_before = 2 . 7375641592668303 E18 - cost_after = 10234 . 800000000001 5 . 2 Query Plan ( before ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Inner hash join ( part . P_PARTKEY = partsupp . PS_PARTKEY ), ( partsupp . PS_SUPPLYCOST = ( select # 2 )) ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Filter : (( part . P_SIZE = 30 ) and ( part . P_TYPE like '%STEEL' )) ( cost = 282 . 66 rows = 774 ) -> Table scan on part ( cost = 282 . 66 rows = 697018 ) -> Hash -> Inner hash join ( partsupp . PS_SUPPKEY = supplier . S_SUPPKEY ) ( cost = 3786224480556435 . 50 rows = 3785350948227630 ) -> Table scan on partsupp ( cost = 0 . 67 rows = 72391 ) -> Hash -> Inner hash join ( supplier . S_NATIONKEY = nation . N_NATIONKEY ) ( cost = 522968063410 . 36 rows = 522903522789 ) -> Table scan on supplier ( cost = 0 . 25 rows = 101512 ) -> Hash -> Inner hash join ( nation . N_REGIONKEY = region . R_REGIONKEY ) ( cost = 51519510 . 02 rows = 51511498 ) -> Table scan on nation ( cost = 0 . 20 rows = 72308 ) -> Hash -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 7308 . 15 rows = 7124 ) -> Table scan on region ( cost = 7308 . 15 rows = 71239 ) 5 . 3 Query Plan ( after ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1562 . 36 rows = 24 ) -> Nested loop inner join ( cost = 1553 . 82 rows = 7 ) -> Nested loop inner join ( cost = 1354 . 61 rows = 142 ) -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Filter : ( part . P_TYPE like '%STEEL' ) ( cost = 1240 . 09 rows = 142 ) -> Index lookup on part using PAW_IDX1645425553 ( P_SIZE = 30 ) ( cost = 1240 . 09 rows = 1276 ) -> Filter : (( partsupp . PS_PARTKEY = part . P_PARTKEY ) and ( partsupp . PS_SUPPLYCOST = ( select # 2 ))) ( cost = 1 . 01 rows = 0 . 05 ) -> Covering index lookup on partsupp using PAW_IDX1922219213 ( PS_SUPPLYCOST = ( select # 2 )) ( cost = 1 . 01 rows = 4 ) -> Select # 2 ( subquery in condition ; dependent ) -> Aggregate : min ( partsupp . PS_SUPPLYCOST ) ( cost = 41 . 31 rows = 1 ) -> Nested loop inner join ( cost = 38 . 82 rows = 25 ) -> Nested loop inner join ( cost = 11 . 53 rows = 25 ) -> Nested loop inner join ( cost = 2 . 84 rows = 7 ) -> Filter : ( region . R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on partsupp using PAW_IDX0326568991 ( PS_PARTKEY = part . P_PARTKEY ) ( cost = 1 . 74 rows = 7 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 )","title":"5. Validation Details"}]}